{"/home/travis/build/npmtest/node-npmtest-bull/test.js":"/* istanbul instrument in package npmtest_bull */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bull/lib.npmtest_bull.js":"/* istanbul instrument in package npmtest_bull */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_bull = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_bull = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-bull/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-bull && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_bull */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_bull\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_bull.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_bull.rollup.js'] =\n            local.assetsDict['/assets.npmtest_bull.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_bull.__dirname + '/lib.npmtest_bull.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bull/node_modules/bull/index.js":"module.exports = require('./lib/queue');\n","/home/travis/build/npmtest/node-npmtest-bull/node_modules/bull/lib/queue.js":"/*eslint-env node */\n'use strict';\n\nvar redis = require('ioredis');\nvar Disturbed = require('disturbed');\nvar util = require('util');\nvar assert = require('assert');\nvar url = require('url');\nvar Job = require('./job');\nvar scripts = require('./scripts');\nvar TimerManager = require('./timer-manager');\nvar _ = require('lodash');\nvar Promise = require('bluebird');\nvar semver = require('semver');\nvar debuglog = require('debuglog')('bull');\n\n/**\n  Gets or creates a new Queue with the given name.\n\n  The Queue keeps 6 data structures:\n    - wait (list)\n    - active (list)\n    - delayed (zset)\n    - priority (zset)\n    - completed (set)\n    - failed (set)\n\n        --> priorities      -- >completed\n       /                   /\n    job -> wait -> active\n        |    ^            \\\n        v    |             -- > failed\n        delayed\n*/\n\n/**\n  Delayed jobs are jobs that cannot be executed until a certain time in\n  ms has passed since they were added to the queue.\n  The mechanism is simple, a delayedTimestamp variable holds the next\n  known timestamp that is on the delayed set (or MAX_TIMEOUT_MS if none).\n\n  When the current job has finalized the variable is checked, if\n  no delayed job has to be executed yet a setTimeout is set so that a\n  delayed job is processed after timing out.\n*/\nvar MINIMUM_REDIS_VERSION = '2.8.11';\nvar LOCK_DURATION = 5000; // 5 seconds is the duration of the lock.\nvar LOCK_RENEW_TIME = LOCK_DURATION / 2; \n\n// The interval for which to check for stalled jobs.\nvar STALLED_JOB_CHECK_INTERVAL = 5000; // 5 seconds is the renew time.\n\n// The maximum number of times a job can be recovered from the 'stalled' state\n// (moved back to 'wait'), before it is failed.\nvar MAX_STALLED_JOB_COUNT = 1;\n\nvar CLIENT_CLOSE_TIMEOUT_MS = 5000;\nvar POLLING_INTERVAL = 5000;\n\nvar REDLOCK_DRIFT_FACTOR = 0.01;\nvar REDLOCK_RETRY_COUNT = 0;\nvar REDLOCK_RETRY_DELAY = 200;\n\nvar MAX_TIMEOUT_MS = Math.pow(2, 31) - 1; // 32 bit signed\n\nvar Queue = function Queue(name, redisPort, redisHost, redisOptions){\n  if(!(this instanceof Queue)){\n    return new Queue(name, redisPort, redisHost, redisOptions);\n  }\n\n  if(_.isObject(redisPort)) {\n    var opts = redisPort;\n    var redisOpts = opts.redis || {};\n    redisPort = redisOpts.port;\n    redisHost = redisOpts.host;\n    redisOptions = redisOpts.opts || {};\n    redisOptions.db = redisOpts.DB || redisOpts.DB;\n  } else if(parseInt(redisPort) == redisPort) {\n    redisPort = parseInt(redisPort);\n    redisOptions =  redisOptions || {};\n  } else if(_.isString(redisPort)) {\n    try {\n      var redisUrl = url.parse(redisPort);\n      assert(_.isObject(redisHost) || _.isUndefined(redisHost),\n          'Expected an object as redis option');\n      redisOptions =  redisHost || {};\n      redisPort = redisUrl.port;\n      redisHost = redisUrl.hostname;\n      if (redisUrl.auth) {\n        redisOptions.password = redisUrl.auth.split(':')[1];\n      }\n    } catch (e) {\n      throw new Error(e.message);\n    }\n  }\n\n  redisOptions = redisOptions || {};\n\n  function createClient(type) {\n    var client;\n    if(_.isFunction(redisOptions.createClient)){\n      client = redisOptions.createClient(type);\n    }else{\n      client = new redis(redisPort, redisHost, redisOptions);\n    }\n    return client;\n  }\n\n  redisPort = redisPort || 6379;\n  redisHost = redisHost || '127.0.0.1';\n\n  var _this = this;\n\n  this.name = name;\n  this.keyPrefix = redisOptions.keyPrefix || 'bull';\n\n  //\n  // We cannot use ioredis keyPrefix feature until we\n  // stop creating keys dynamically in lua scripts.\n  //\n  delete redisOptions.keyPrefix;\n\n  //\n  // Create queue client (used to add jobs, pause queues, etc);\n  //\n  this.client = createClient('client');\n\n  getRedisVersion(this.client).then(function(version){\n    if(semver.lt(version, MINIMUM_REDIS_VERSION)){\n      throw new Error('Redis version needs to be greater than ' + MINIMUM_REDIS_VERSION + '. Current: ' + version);\n    }\n  }).catch(function(err){\n    _this.emit('error', err);\n  });\n\n  //\n  // Keep track of cluster clients for redlock\n  //\n  this.clients = [this.client];\n  if (redisOptions.clients) {\n    this.clients.push.apply(this.clients, redisOptions.clients);\n  }\n  this.redlock = {\n    driftFactor: REDLOCK_DRIFT_FACTOR,\n    retryCount: REDLOCK_RETRY_COUNT,\n    retryDelay: REDLOCK_RETRY_DELAY\n  };\n  _.extend(this.redlock, redisOptions.redlock || {});\n\n  //\n  // Create blocking client (used to wait for jobs)\n  //\n  this.bclient = createClient('block');\n\n  //\n  // Create event subscriber client (receive messages from other instance of the queue)\n  //\n  this.eclient = createClient('subscriber');\n\n  this.delayTimer = null;\n  this.processing = 0;\n  this.retrieving = 0;\n\n  this.LOCK_RENEW_TIME = LOCK_RENEW_TIME;\n  this.LOCK_DURATION = LOCK_DURATION;\n  this.STALLED_JOB_CHECK_INTERVAL = STALLED_JOB_CHECK_INTERVAL;\n  this.MAX_STALLED_JOB_COUNT = MAX_STALLED_JOB_COUNT;\n\n  // bubble up Redis error events\n  [this.client, this.bclient, this.eclient].forEach(function (client) {\n    client.on('error', _this.emit.bind(_this, 'error'));\n  });\n\n  // keeps track of active timers. used by close() to\n  // ensure that disconnect() is deferred until all\n  // scheduled redis commands have been executed\n  this.timers = new TimerManager();\n\n  // emit ready when redis connections ready\n  var initializers = [this.client, this.bclient, this.eclient].map(function (client) {\n    return new Promise(function(resolve, reject) {\n      client.once('ready', resolve);\n      client.once('error', reject);\n    });\n  });\n\n  this._initializing = Promise.all(initializers).then(function(){\n    return Promise.join(\n      _this.eclient.subscribe(_this.toKey('delayed')),\n      _this.eclient.subscribe(_this.toKey('paused'))\n    );\n  }).then(function(){\n    debuglog(name + ' queue ready');\n    _this.emit('ready');\n  }, function(err){\n    console.error('Error initializing queue:', err);\n  });\n\n  Disturbed.call(this, _this.client, _this.eclient);\n\n  //\n  // Listen distributed queue events\n  //\n  listenDistEvent('stalled'); //\n  listenDistEvent('active'); //\n  listenDistEvent('completed'); //\n  listenDistEvent('failed'); //\n  listenDistEvent('cleaned');\n  listenDistEvent('waiting'); //\n  listenDistEvent('remove'); //\n  listenDistEvent('progress'); //\n\n  function listenDistEvent(eventName){\n    var _eventName = eventName + '@' + name;\n    _this.on(_eventName, function(){\n      var args = Array.prototype.slice.call(arguments);\n\n      if(eventName !== 'cleaned' && eventName !== 'error'){\n        args[0] = Job.fromJSON(_this, args[0]);\n      }\n\n      args.unshift('global:' + eventName);\n      _this.emit.apply(_this, args);\n    }, true);\n  }\n\n  //\n  // Handle delay, pause and resume messages\n  //\n  var delayedKey = _this.toKey('delayed');\n  var pausedKey = _this.toKey('paused');\n  this.eclient.on('message', function(channel, message){\n    if(channel === delayedKey){\n      _this.updateDelayTimer(message);\n    }else if(channel === pausedKey){\n      _this.emit(message);\n    }\n  });\n\n  //\n  // Init delay timestamp.\n  //\n  this.delayedTimestamp = Number.MAX_VALUE;\n  scripts.updateDelaySet(this, Date.now()).then(function(timestamp){\n    if(timestamp){\n      _this.updateDelayTimer(timestamp);\n    }\n  });\n\n  //\n  // Create a guardian timer to revive delayTimer if necessary\n  // This is necessary when redis connection is unstable, which can cause the pub/sub to fail\n  //\n  this.guardianTimer = setInterval(function() {\n    if(_this.delayedTimestamp < Date.now() || _this.delayedTimestamp - Date.now() > POLLING_INTERVAL){\n      scripts.updateDelaySet(_this, Date.now()).then(function(timestamp){\n        if(timestamp){\n          _this.updateDelayTimer(timestamp);\n        }\n      }).catch(function(err){\n        console.error(err);\n      });\n    }\n  }, POLLING_INTERVAL);\n\n  // Bind these methods to avoid constant rebinding and/or creating closures\n  // in processJobs etc.\n  this.moveUnlockedJobsToWait = this.moveUnlockedJobsToWait.bind(this);\n  this.getNextJob = this.getNextJob.bind(this);\n  this.processJobs = this.processJobs.bind(this);\n  this.processJob = this.processJob.bind(this);\n  this.getJobFromId = Job.fromId.bind(null, this);\n};\n\nutil.inherits(Queue, Disturbed);\n\nQueue.prototype.isReady = function(){\n  var _this = this;\n  return this._initializing.then(function(){\n    return _this;\n  });\n}\n\nQueue.prototype.getJobMoveCount = function(){\n  return this.bclient.commandQueue.length;\n};\n\nQueue.prototype.whenCurrentMoveFinished = function(){\n  var currentMove = this.bclient.commandQueue.peekFront()\n  return currentMove && currentMove.command.promise || Promise.resolve();\n};\n/**\n *\n * Emits a distributed event.\n */\nQueue.prototype.distEmit = function(){\n  var args = Array.prototype.slice.call(arguments);\n\n   // Emit local event\n  this.emit.apply(this, args);\n\n  // Emit global event\n  args[0] = args[0] + '@' + this.name;\n  return Disturbed.prototype.distEmit.apply(this, args);\n}\n\nQueue.prototype.on = function(){\n  var args = Array.prototype.slice.call(arguments);\n  var promise = Disturbed.prototype.on.apply(this, args);\n  var _this = this;\n  promise.catch(function(err){ _this.emit('error', err); });\n  return this;\n};\n\nQueue.prototype.once = function(){\n  var args = Array.prototype.slice.call(arguments);\n  Disturbed.prototype.once.apply(this, args);\n  return this;\n};\n\nQueue.prototype.disconnect = function(){\n  var _this = this;\n\n  function endClients(){\n    var timeoutMsg = 'Timed out while waiting for redis clients to close';\n\n    return new Promise(function(resolve) {\n      _this.bclient.end(true);\n      _this.bclient.stream.once('close', resolve);\n    }).timeout(CLIENT_CLOSE_TIMEOUT_MS, timeoutMsg)\n    .catch(function(err){\n      if(!(err instanceof Promise.TimeoutError)){\n        throw err;\n      }\n    });\n  }\n\n  return Promise.join(\n    _this.client.quit(),\n    _this.eclient.quit()\n  ).then(endClients, endClients);\n};\n\nQueue.prototype.close = function( doNotWaitJobs ){\n  var _this = this;\n\n  if(this.closing){\n    return this.closing;\n  }\n\n\n  return this.closing = this._initializing.then(function(){\n    clearTimeout(_this.delayTimer);\n    clearInterval(_this.guardianTimer);\n    clearInterval(_this.moveUnlockedJobsToWaitInterval);\n    _this.timers.clearAll();\n\n    return _this.timers.whenIdle().then(function(){\n      return _this.pause(true, doNotWaitJobs);\n    }).then(function(){\n      return _this.disconnect();\n    }).then(function(){\n      _this.closed = true;\n    });\n  });\n};\n\n/**\n  Processes a job from the queue. The callback is called for every job that\n  is dequeued.\n\n  @method process\n*/\nQueue.prototype.process = function(concurrency, handler){\n  var _this = this;\n  if(typeof concurrency === 'function'){\n    handler = concurrency;\n    concurrency = 1;\n  }\n\n  this.setHandler(handler);\n\n  var runQueueWhenReady = function(){\n    _this.bclient.once('ready', function(){\n      _this.run(concurrency).catch(function(err){\n        console.error(err);\n      });\n    });\n  };\n\n  // attempt to restart the queue when the client throws\n  // an error or the connection is dropped by redis\n  this.bclient.on('error', runQueueWhenReady);\n  this.bclient.on('end', runQueueWhenReady);\n\n  return this.run(concurrency).catch(function(err){\n    console.error(err);\n    throw err;\n  });\n};\n\nQueue.prototype.setHandler = function(handler){\n  if(this.handler) {\n    throw new Error('Cannot define a handler more than once per Queue instance');\n  }\n\n  handler = handler.bind(this);\n\n  if(handler.length > 1){\n    this.handler = Promise.promisify(handler);\n  }else{\n    this.handler = Promise.method(handler);\n  }\n};\n\n/**\ninterface JobOptions\n{\n  attempts: number;\n}\n*/\n\n/**\n  Adds a job to the queue.\n  @method add\n  @param data: {} Custom data to store for this job. Should be JSON serializable.\n  @param opts: JobOptions Options for this job.\n*/\nQueue.prototype.add = function(data, opts){\n  return Job.create(this, data, opts);\n};\n\n/**\n  Returns the number of jobs waiting to be processed.\n*/\nQueue.prototype.count = function(){\n  var multi = this.multi();\n  multi.llen(this.toKey('wait'));\n  multi.llen(this.toKey('paused'));\n  multi.zcard(this.toKey('delayed'));\n\n  return multi.exec().then(function(res){\n    return Math.max(res[0][1], res[1][1]) + res[2][1];\n  });\n};\n\n/**\n  Empties the queue.\n\n  Returns a promise that is resolved after the operation has been completed.\n  Note that if some other process is adding jobs at the same time as emptying,\n  the queues may not be really empty after this method has executed completely.\n  Also, if the method does error between emptying the lists and removing all the\n  jobs, there will be zombie jobs left in redis.\n\n  TODO: Use EVAL to make this operation fully atomic.\n*/\nQueue.prototype.empty = function(){\n  var _this = this;\n\n  // Get all jobids and empty all lists atomically.\n  var multi = this.multi();\n\n  multi.lrange(this.toKey('wait'), 0, -1);\n  multi.lrange(this.toKey('paused'), 0, -1);\n  multi.del(this.toKey('wait'));\n  multi.del(this.toKey('paused'));\n  multi.del(this.toKey('meta-paused'));\n  multi.del(this.toKey('delayed'));\n\n  return multi.exec().spread(function(waiting, paused){\n    waiting = waiting[1];\n    paused = paused[1];\n    var jobKeys = (paused.concat(waiting)).map(_this.toKey, _this);\n\n    if(jobKeys.length){\n      multi = _this.multi();\n\n      multi.del.apply(multi, jobKeys);\n      return multi.exec();\n    }\n  });\n};\n\n/**\n  Pauses the processing of this queue, locally if true passed, otherwise globally.\n\n  For global pause, we use an atomic RENAME operation on the wait queue. Since\n  we have blocking calls with BRPOPLPUSH on the wait queue, as long as the queue\n  is renamed to 'paused', no new jobs will be processed (the current ones\n  will run until finalized).\n\n  Adding jobs requires a LUA script to check first if the paused list exist\n  and in that case it will add it there instead of the wait list.\n*/\nQueue.prototype.pause = function(isLocal, doNotWaitActive){\n  if(isLocal){\n    var _this = this;\n\n    if(!this.paused){\n      this.paused = new Promise(function(resolve) {\n        _this.resumeLocal = function() {\n          resolve();\n          _this.paused = null; // Allow pause to be checked externally for paused state.\n        };\n      });\n    }\n\n    return !doNotWaitActive && this.whenCurrentJobsFinished();\n  }else{\n    return pauseResumeGlobal(this, true);\n  }\n};\n\nQueue.prototype.resume = function(isLocal /* Optional */){\n  if(isLocal){\n    if(this.resumeLocal){\n      this.resumeLocal();\n    }\n    return Promise.resolve();\n  }else{\n    return pauseResumeGlobal(this, false);\n  }\n};\n\n//\n// TODO: move to scripts module.\n//\nfunction pauseResumeGlobal(queue, pause){\n  var src = 'wait', dst = 'paused';\n  if(!pause){\n    src = 'paused';\n    dst = 'wait';\n  }\n\n  var script = [\n    'if redis.call(\"EXISTS\", KEYS[1]) == 1 then',\n    ' redis.call(\"RENAME\", KEYS[1], KEYS[2])',\n    'end',\n    'if ARGV[1] == \"paused\" then',\n    ' redis.call(\"SET\", KEYS[3], 1)',\n    'else',\n    ' redis.call(\"DEL\", KEYS[3])',\n    'end',\n    'redis.call(\"PUBLISH\", KEYS[4], ARGV[1])'\n  ].join('\\n');\n\n  var keys = _.map([src, dst, 'meta-paused', 'paused'], function(name){\n    return queue.toKey(name);\n  });\n\n  return queue.client.eval(script, keys.length, keys[0], keys[1], keys[2], keys[3], pause ? 'paused' : 'resumed');\n}\n\nQueue.prototype.run = function(concurrency){\n  var promises = [];\n  var _this = this;\n\n  return this.moveUnlockedJobsToWait().then(function(){\n\n    while(concurrency--){\n      promises.push(new Promise(_this.processJobs));\n    }\n\n    _this.startMoveUnlockedJobsToWait();\n\n    return Promise.all(promises);\n  });\n};\n\n// ---------------------------------------------------------------------\n// Private methods\n// ---------------------------------------------------------------------\n\n/**\n  This function updates the delay timer, which is a timer that timeouts\n  at the next known delayed job.\n*/\nQueue.prototype.updateDelayTimer = function(newDelayedTimestamp){\n  var _this = this;\n\n  if(newDelayedTimestamp < _this.delayedTimestamp && newDelayedTimestamp < (MAX_TIMEOUT_MS + Date.now())){\n    clearTimeout(this.delayTimer);\n    this.delayedTimestamp = newDelayedTimestamp;\n\n    var nextDelayedJob = newDelayedTimestamp - Date.now();\n    nextDelayedJob = nextDelayedJob < 0 ? 0 : nextDelayedJob;\n\n    this.delayTimer = setTimeout(function(){\n      scripts.updateDelaySet(_this, _this.delayedTimestamp).then(function(nextTimestamp){\n        if(nextTimestamp){\n          nextTimestamp = nextTimestamp < Date.now() ? Date.now() : nextTimestamp;\n        }else{\n          nextTimestamp = Number.MAX_VALUE;\n        }\n        _this.updateDelayTimer(nextTimestamp);\n      }).catch(function(err){ \n        console.error('Error updating the delay timer', err);\n      });\n      _this.delayedTimestamp = Number.MAX_VALUE;\n    }, nextDelayedJob);\n  }\n};\n\n/**\n * Process jobs that have been added to the active list but are not being\n * processed properly. This can happen due to a process crash in the middle\n * of processing a job, leaving it in 'active' but without a job lock.\n*/\nQueue.prototype.moveUnlockedJobsToWait = function(){\n  var _this = this;\n\n  return scripts.moveUnlockedJobsToWait(this).then(function(responses){\n    var handleFailedJobs = responses[0].map(function(jobId){\n      return _this.getJobFromId(jobId).then(function(job){\n        _this.distEmit('failed', job, new Error('job stalled more than allowable limit'));\n        return null;\n      });\n    });\n    var handleStalledJobs = responses[1].map(function(jobId){\n      return _this.getJobFromId(jobId).then(function(job){\n        _this.distEmit('stalled', job);\n        return null;\n      });\n    });\n    return Promise.all(handleFailedJobs.concat(handleStalledJobs));\n  }).catch(function(err){\n    console.error('Failed to handle unlocked job in active:', err);\n  });\n};\n\nQueue.prototype.startMoveUnlockedJobsToWait = function() {\n  if (this.STALLED_JOB_CHECK_INTERVAL > 0){\n    clearInterval(this.moveUnlockedJobsToWaitInterval);\n    this.moveUnlockedJobsToWaitInterval =\n      setInterval(this.moveUnlockedJobsToWait, this.STALLED_JOB_CHECK_INTERVAL);\n  }\n};\n\nQueue.prototype.processJobs = function(resolve, reject){\n  var _this = this;\n  var processJobs = this.processJobs.bind(this, resolve, reject);\n\n  if(!this.closing){\n    process.nextTick(function(){\n      (_this.paused || Promise.resolve())\n        .then(_this.getNextJob)\n        .then(_this.processJob)\n        .then(processJobs, function(err){\n          console.error('Error processing job:', err);\n          processJobs();\n        }).catch(reject);\n    });\n  }else{\n    resolve(this.closing);\n  }\n};\n\nQueue.prototype.processJob = function(job){\n  var _this = this;\n  var lockRenewId;\n  var timmerStopped = false;\n\n  if(!job){\n    return Promise.resolve();\n  }\n\n  //\n  // TODO:\n  // There are two cases to take into consideration regarding locks.\n  // 1) The lock renewer fails to renew a lock, this should make this job\n  // unable to complete, since some other worker is also working on it.\n  // 2) The lock renewer is called more seldom than the check for stalled\n  // jobs, so we can assume the job has been stalled and is already being processed\n  // by another worker. See #308\n  //\n  var renew = false;\n  var lockRenewer = function(){\n    return job.takeLock(renew, true).then(function(lock){\n      if(lock && !timmerStopped){\n        renew = true;\n        lockRenewId = _this.timers.set('lockRenewer', _this.LOCK_RENEW_TIME, lockRenewer);\n      }\n      // TODO: if we failed to re-acquire the lock while trying to renew, should we let the job\n      // handler know and cancel the timer?\n      return lock;\n    }, function(err){\n      console.error('Error renewing lock ' + err);\n    });\n  };\n\n  var timeoutMs = job.opts.timeout;\n\n  function stopTimer(){\n    timmerStopped = true;\n    _this.timers.clear(lockRenewId);\n    return Promise.resolve();\n  }\n\n  function handleCompleted(data){\n    try{\n      JSON.stringify(data);\n    }catch(err){\n      return handleFailed(err);\n    }\n    // This substraction is duplicate in handleCompleted and handleFailed because it have to be made before throwing any\n    // event completed or failed in order to allow pause() to work correctly without getting stuck.\n    _this.processing--;\n\n    stopTimer();\n\n    if(_this.closed){\n      return;\n    }\n\n    return job.moveToCompleted(data).then(function(){\n      return _this.distEmit('completed', job, data);\n    });\n  }\n\n  function handleFailed(err){\n    var error = err.cause || err; //Handle explicit rejection\n\n    // TODO: Should moveToFailed ensure the lock atomically in one of its Lua scripts?\n    // See https://github.com/OptimalBits/bull/pull/415#issuecomment-269744735\n    job.takeLock(true /* renwew */, false /* ensureActive */).then( function(lock) {\n      return stopTimer()\n        .then(job.moveToFailed(err))\n        .then(job.releaseLock.bind(job))\n        .then(function(){\n          return _this.distEmit('failed', job, error);\n        });\n    }, function(err){\n      console.error('failed to re-obtain lock before moving to failed, bailing: ', err);\n      stopTimer();\n    });\n    _this.processing--;\n  }\n\n  return lockRenewer().then(function(locked){\n    if(locked){\n      var jobPromise = _this.handler(job);\n\n      if(timeoutMs){\n        jobPromise = jobPromise.timeout(timeoutMs);\n      }\n\n      _this.distEmit('active', job, jobPromise);\n\n      return jobPromise\n        .then(handleCompleted, handleFailed);\n    }\n  });\n};\n\n/**\n  Returns a promise that resolves to the next job in queue.\n*/\nQueue.prototype.getNextJob = function(opts){\n  var _this = this;\n  if(!this.closing){\n    this.retrieving++;\n    return this.moveJob('wait', 'active', opts)\n      .then(this.getJobFromId)\n      .tap(function(job) {\n        _this.retrieving--;\n        if (job) {\n          _this.processing++;\n        } else {\n          _this.emit('no-job-retrieved');\n        }\n      })\n      .catch(function(err) {\n        _this.retrieving--;\n        _this.emit('no-job-retrieved');\n        throw err;\n      });\n  }else{\n    return Promise.reject();\n  }\n};\n\nQueue.prototype.multi = function(){\n  return this.client.multi();\n};\n\n/**\n  Atomically moves a job from one list to another.\n\n  @method moveJob\n*/\nQueue.prototype.moveJob = function(src, dst, opts) {\n  var args = arguments;\n  var _this = this;\n  var move;\n  if(opts && opts.block === false){\n    if(!this.closing){\n      move = this.bclient.rpoplpush(this.toKey(src), this.toKey(dst));\n    }else{\n      move = Promise.reject();\n    }\n  } else if (this.closing || this.paused) {\n    move = Promise.resolve();\n  } else if (this.getJobMoveCount()) {\n    move = this.whenCurrentMoveFinished().then(function() {\n      return _this.moveJob.apply(_this, args);\n    });\n  }else{\n    move = this.bclient.brpoplpush(\n      this.toKey(src),\n      this.toKey(dst),\n      Math.floor(this.LOCK_RENEW_TIME / 1000));\n  }\n\n  return move.then(function(jobId){\n    //\n    // Unfortunatelly this cannot be performed atomically, which will lead to a\n    // slight hazard for priority queues (will only affect its order).\n    //\n    if(jobId){\n      return _this.client.zrem(_this.toKey('priority'), jobId).then(function(){\n        return jobId;\n      });\n    }\n  }, function(err){\n    if(!_this.closing){\n      throw err;\n    }\n  });\n};\n\nQueue.prototype.getJob = function(jobId){\n  return Job.fromId(this, jobId);\n};\n\n// Job counts by type\n// Queue#getJobCountByTypes('completed') => completed count\n// Queue#getJobCountByTypes('completed,failed') => completed + failed count\n// Queue#getJobCountByTypes('completed', 'failed') => completed + failed count\n// Queue#getJobCountByTypes('completed,waiting', 'failed') => completed + waiting + failed count\nQueue.prototype.getJobCountByTypes = function() {\n  var _this = this;\n  var args = _.compact(Array.prototype.slice.call(arguments));\n  var types = _.compact(args.join(',').replace(/ /g, '').split(','));\n\n  var multi = this.multi();\n\n  _.each(types, function(type) {\n    var key = _this.toKey(type);\n    switch(type) {\n      case 'completed':\n      case 'failed':\n        multi.scard(key);\n        break;\n      case 'delayed':\n        multi.zcard(key);\n        break;\n      case 'active':\n      case 'wait':\n      case 'paused':\n        multi.llen(key);\n        break;\n    }\n  });\n\n  return multi.exec().then(function(res){\n    return res.map(function(v) {\n      return v[1]\n    }).reduce(function(a, b) {\n      return a + b\n    });\t     \n  }) || 0;\n};\n\n/**\n * Returns all the job counts for every list/set in the queue.\n * \n */\nQueue.prototype.getJobCounts = function(){\n  var types = ['wait', 'active', 'completed', 'failed', 'delayed'];\n  var counts = {};\n  return this.client.multi()\n    .llen(this.toKey('wait'))\n    .llen(this.toKey('active'))\n    .scard(this.toKey('completed'))\n    .scard(this.toKey('failed'))\n    .zcard(this.toKey('delayed'))\n    .exec().then(function(result){\n      result.forEach(function(res, index){\n        counts[types[index]] = res[1] || 0;\n      });\n      return counts;\n    });\n};\n\nQueue.prototype.getCompletedCount = function() {\n  return this.client.scard(this.toKey('completed'));\n};\n\nQueue.prototype.getFailedCount = function() {\n  return this.client.scard(this.toKey('failed'));\n};\n\nQueue.prototype.getDelayedCount = function() {\n  return this.client.zcard(this.toKey('delayed'));\n};\n\nQueue.prototype.getActiveCount = function() {\n  return this.client.llen(this.toKey('active'));\n};\n\nQueue.prototype.getWaitingCount = function() {\n  return this.client.llen(this.toKey('wait'));\n};\n\nQueue.prototype.getPausedCount = function() {\n  return this.client.llen(this.toKey('paused'));\n};\n\nQueue.prototype.getWaiting = function(/*start, end*/){\n  return Promise.join(\n    this.getJobs('wait', 'LIST'),\n    this.getJobs('paused', 'LIST')).spread(function(waiting, paused){\n      return _.concat(waiting, paused);\n    });\n};\n\nQueue.prototype.getActive = function(/*start, end*/){\n  return this.getJobs('active', 'LIST');\n};\n\nQueue.prototype.getDelayed = function(/*start, end*/){\n  return this.getJobs('delayed', 'ZSET');\n};\n\nQueue.prototype.getCompleted = function(){\n  return this.getJobs('completed', 'SET');\n};\n\nQueue.prototype.getFailed = function(){\n  return this.getJobs('failed', 'SET');\n};\n\nQueue.prototype.getJobs = function(queueType, type, start, end){\n  var _this = this;\n  var key = this.toKey(queueType);\n  var jobs;\n\n  start = _.isUndefined(start) ? 0 : start;\n  end = _.isUndefined(end) ? -1 : end;\n\n  switch(type){\n    case 'LIST':\n      jobs = this.client.lrange(key, start, end);\n      break;\n    case 'SET':\n      jobs = this.client.smembers(key).then(function(jobIds) {\n        // Can't set a range for smembers. So do the slice programatically instead.\n        // Note that redis ranges are inclusive, so handling for javascript accordingly\n        if (end === -1) {\n          return jobIds.slice(start);\n        }\n\n        return jobIds.slice(start, end + 1);\n      });\n      break;\n    case 'ZSET':\n      jobs = this.client.zrange(key, start, end);\n      break;\n  }\n\n  return jobs.then(function(jobIds){\n    var jobsFromId = jobIds.map(_this.getJobFromId);\n    return Promise.all(jobsFromId);\n  });\n};\n\nQueue.prototype.retryJob = function(job) {\n  return job.retry();\n};\n\nQueue.prototype.toKey = function(queueType){\n  return [this.keyPrefix, this.name, queueType].join(':');\n};\n\n/*@function startCleaner\n *\n * Cleans jobs from a queue. Similar to remove but keeps jobs within a certian\n * grace period.\n *\n * @param {int} grace - The grace period\n * @param {string} [type=completed] - The type of job to clean. Possible values\n * @param {int} The max number of jobs to clean\n * are completed, waiting, active, delayed, failed. Defaults to completed.\n */\nQueue.prototype.clean = function (grace, type, limit) {\n  var _this = this;\n\n  return new Promise(function (resolve, reject) {\n    if(grace === undefined || grace === null) {\n      return reject(new Error('You must define a grace period.'));\n    }\n\n    if(!type) {\n      type = 'completed';\n    }\n\n    if(_.indexOf([\n      'completed',\n      'wait',\n      'active',\n      'delayed',\n      'failed'], type) === -1){\n      return reject(new Error('Cannot clean unkown queue type'));\n    }\n\n    return scripts.cleanJobsInSet(_this, type, Date.now() - grace, limit).then(function (jobs) {\n      _this.distEmit('cleaned', jobs, type);\n      resolve(jobs);\n      return null;\n    }).catch(function (err) {\n      _this.emit('error', err);\n      reject(err);\n    });\n  });\n};\n\n/**\n * Returns a promise that resolves when active jobs are cleared\n *\n * @returns {Promise}\n */\nQueue.prototype.whenCurrentJobsFinished = function(){\n  var _this = this;\n  var resolver;\n  var count = this.processing + this.retrieving;\n  return new Promise(function(resolve) {\n    if(count === 0){\n      resolve();\n    }else{\n      resolver = _.after(count, function(){\n        _this.removeListener('stalled', resolver);\n        _this.removeListener('completed', resolver);\n        _this.removeListener('failed', resolver);\n        _this.removeListener('no-job-retrieved', resolver);\n        clearInterval(_this.moveUnlockedJobsToWaitInterval);\n        resolve();\n      });\n\n      _this.on('stalled', resolver);\n      _this.on('completed', resolver);\n      _this.on('failed', resolver);\n      _this.on('no-job-retrieved', resolver);\n\n      _this.startMoveUnlockedJobsToWait();\n    }\n  });\n};\n\n//\n// Private local functions\n//\nvar getRedisVersion = function getRedisVersion(client){\n  return client.info().then(function(doc){\n    var prefix = 'redis_version:';\n    var lines = doc.split('\\r\\n');\n    for(var i = 0; i < lines.length; i++){\n      if(lines[i].indexOf(prefix) === 0){\n        return lines[i].substr(prefix.length);\n      }\n    }\n  });\n};\n\nmodule.exports = Queue;\n","/home/travis/build/npmtest/node-npmtest-bull/node_modules/bull/lib/job.js":"/*eslint-env node */\n'use strict';\n\nvar Promise = require('bluebird');\nvar _ = require('lodash');\nvar scripts = require('./scripts');\nvar debuglog = require('debuglog')('bull');\n\n/**\ninterface JobOptions\n{\n  priority: Priority;\n  attempts: number;\n}\n*/\n\n// queue: Queue, data: {}, opts: JobOptions\nvar Job = function(queue, data, opts){\n  opts = opts || {};\n  this.queue = queue;\n  this.data = data;\n  this.opts = opts;\n  this._progress = 0;\n  this.delay = opts.delay || 0;\n  this.timestamp = opts.timestamp || Date.now();\n  this.stacktrace = [];\n  if(this.opts.attempts > 1){\n    this.attempts = opts.attempts;\n  }else{\n    this.attempts = 1;\n  }\n  this.returnvalue = null;\n  this.attemptsMade = 0;\n};\n\nfunction addJob(queue, job){\n  var opts = job.opts;\n  var jobData = job.toData();\n  var toKey = _.bind(queue.toKey, queue);\n  return scripts.addJob(queue.client, toKey, jobData, {\n    lifo: opts.lifo,\n    customJobId: opts.jobId,\n    priority: opts.priority \n  });\n}\n\nJob.create = function(queue, data, opts){\n  var job = new Job(queue, data, opts);\n\n  return addJob(queue, job).then(function(jobId){\n    job.jobId = jobId;\n    queue.distEmit('waiting', job.toJSON());\n    debuglog('Job added', jobId);\n    return job;\n  });\n};\n\nJob.fromId = function(queue, jobId){\n  // jobId can be undefined if moveJob returns undefined\n  if(!jobId) {\n    return Promise.resolve();\n  }\n  return queue.client.hgetall(queue.toKey(jobId)).then(function(jobData){\n    if(!_.isEmpty(jobData)){\n      return Job.fromData(queue, jobId, jobData);\n    }else{\n      return null;\n    }\n  });\n};\n\nJob.prototype.toData = function(){\n  return {\n    data: JSON.stringify(this.data || {}),\n    opts: JSON.stringify(this.opts || {}),\n    progress: this._progress,\n    delay: this.delay,\n    timestamp: this.timestamp,\n    attempts: this.attempts,\n    attemptsMade: this.attemptsMade,\n    failedReason: this.failedReason,\n    stacktrace: JSON.stringify(this.stacktrace || null),\n    returnvalue: JSON.stringify(this.returnvalue || null)\n  };\n};\n\nJob.prototype.progress = function(progress){\n  if(progress){\n    var _this = this;\n    this._progress = progress;\n    return this.queue.client.hset(this.queue.toKey(this.jobId), 'progress', progress).then(function(){\n      _this.queue.distEmit('progress', _this.toJSON(), progress);\n    });\n  }else{\n    return this._progress;\n  }\n};\n\n//\n// toData and fromData should be deprecated.\n//\nJob.prototype.toJSON = function(){\n  var opts = _.extend({}, this.opts || {});\n  opts.jobId = this.jobId;\n  return {\n    id: this.jobId,\n    data: this.data || {},\n    opts: opts,\n    progress: this._progress,\n    delay: this.delay,\n    timestamp: this.timestamp,\n    attempts: this.attempts,\n    attemptsMade: this.attemptsMade,\n    failedReason: this.failedReason,\n    stacktrace: this.stacktrace || null,\n    returnvalue: this.returnvalue || null\n  };\n};\n\n/**\n  Return a unique key representing a lock for this Job\n*/\nJob.prototype.lockKey = function(){\n  return this.queue.toKey(this.jobId) + ':lock';\n};\n\n/**\n  Takes a lock for this job so that no other queue worker can process it at the\n  same time.\n*/\nJob.prototype.takeLock = function(renew, ensureActive){\n  var _this = this;\n  return scripts.takeLock(this.queue, this, renew, ensureActive).then(function(lock) {\n    if (lock){\n      _this.lock = lock;\n    } \n    return lock || false;\n  });\n};\n\n/**\n  Renews a lock so that it gets some more time before expiring.\n*/\nJob.prototype.renewLock = function(){\n  return this.takeLock(true /* Renew */);\n};\n\n/**\n  Releases the lock. Only locks owned by the queue instance can be released.\n*/\nJob.prototype.releaseLock = function(){\n  var _this = this;\n  return scripts.releaseLock(this)\n  .then(function() { _this.lock = null; });\n};\n\nJob.prototype.delayIfNeeded = function(){\n  if(this.delay){\n    var jobDelayedTimestamp = this.timestamp + this.delay;\n    if(jobDelayedTimestamp > Date.now()){\n      return this.moveToDelayed(jobDelayedTimestamp).then(function(){\n        return true;\n      });\n    }\n  }\n  return Promise.resolve(false);\n};\n\nJob.prototype.moveToCompleted = function(returnValue){\n  this.returnvalue = returnValue || 0;\n  return scripts.moveToCompleted(this, this.opts.removeOnComplete);\n};\n\nJob.prototype.move = function(src, target, returnValue){\n  if(target === 'completed'){\n    this.returnvalue = returnValue || 0;\n    if(this.opts.removeOnComplete){\n      target = void 0;\n    }\n  }\n  return scripts.move(this, src, target);\n}\n\nJob.prototype.discard = function(){\n  this._discarded = true;\n}\n\nJob.prototype.moveToFailed = function(err){\n  var _this = this;\n  return this._saveAttempt(err).then(function() {\n    // Check if an automatic retry should be performed\n    if(_this.attemptsMade < _this.attempts && !_this._discarded){\n      // Check if backoff is needed\n      var backoff = _this._getBackOff();\n      if(backoff){\n        // If so, move to delayed\n        return _this.moveToDelayed(Date.now() + backoff);\n      }else{\n        // If not, retry immediately\n        return _this._retryAtOnce();\n      }\n    } else if(_this.opts.removeOnFail){\n      return _this.releaseLock().then(function(){\n        return _this.remove();\n      });\n    }\n    // If not, move to failed\n    return _this._moveToSet('failed');\n  });\n};\n\nJob.prototype.moveToDelayed = function(timestamp){\n  return this._moveToSet('delayed', timestamp);\n};\n\nJob.prototype.promote = function(){\n  var queue = this.queue;\n  var jobId = this.jobId;\n\n  var script = [\n    'if redis.call(\"ZREM\", KEYS[1], ARGV[1]) == 1 then',\n    ' redis.call(\"LPUSH\", KEYS[2], ARGV[1])',\n    ' return 0',\n    'else',\n    ' return -1',\n    'end'\n  ].join('\\n');\n\n  var keys = _.map(['delayed', 'wait'], function(name){\n    return queue.toKey(name);\n  });\n\n  return queue.client.eval(\n    script,\n    keys.length,\n    keys[0],\n    keys[1],\n    jobId).then(function(result){\n      if(result === -1){\n        throw new Error('Job ' + jobId + ' is not in a delayed state');\n      }\n    });\n};\n\n/**\n * Attempts to retry the job. Only a job that has failed can be retried.\n *\n * @return {Promise} If resolved and return code is 1, then the queue emits a waiting event\n * otherwise the operation was not a success and throw the corresponding error. If the promise\n * rejects, it indicates that the script failed to execute\n */\nJob.prototype.retry = function(){\n  var queue = this.queue;\n  var _this = this;\n  return scripts.reprocessJob(this, { state: 'failed' }).then(function(result) {\n    if (result === 1) {\n      queue.emit('waiting', _this);\n    } else if (result === 0) {\n      throw new Error('Couldn\\'t retry job: The job doesn\\'t exist');\n    } else if (result === -1) {\n      throw new Error('Couldn\\'t retry job: The job is locked');\n    } else if (result === -2) {\n      throw new Error('Couldn\\'t retry job: The job has been already retried or has not failed');\n    }\n  });\n};\n\nJob.prototype.isCompleted = function(){\n  return this._isDone('completed');\n};\n\nJob.prototype.isFailed = function(){\n  return this._isDone('failed');\n};\n\nJob.prototype.isDelayed = function() {\n  return this.queue.client\n    .zrank(this.queue.toKey('delayed'), this.jobId).then(function(rank) {\n      return rank !== null;\n    });\n};\n\nJob.prototype.isActive = function() {\n  return this._isInList('active');\n};\n\nJob.prototype.isWaiting = function() {\n  return this._isInList('wait');\n};\n\nJob.prototype.isPaused = function() {\n  return this._isInList('paused');\n};\n\nJob.prototype.isStuck = function() {\n  return this.getState().then(function(state) {\n    return state === 'stuck';\n  });\n};\n\nJob.prototype.getState = function() {\n  var _this = this;\n  var fns = [\n    { fn: 'isCompleted', state: 'completed' },\n    { fn: 'isFailed', state: 'failed' },\n    { fn: 'isDelayed', state: 'delayed' },\n    { fn: 'isActive', state: 'active' },\n    { fn: 'isWaiting', state: 'waiting' },\n    { fn: 'isPaused', state: 'paused' }\n  ];\n\n  return Promise.reduce(fns, function(state, fn) {\n    if(state){\n      return state;\n    }\n    return _this[fn.fn]().then(function(result) {\n      return result ? fn.state : null;\n    });\n  }, null).then(function(result) {\n    return result ? result : 'stuck';\n  });\n};\n\n/**\n  Removes a job from the queue and from all the lists where it may be stored.\n*/\nJob.prototype.remove = function(){\n  var queue = this.queue;\n  var job = this;\n\n  return job.takeLock().then(function(lock) {\n    if (!lock) {\n      throw new Error('Could not get lock for job: ' + job.jobId + '. Cannot remove job.');\n    }\n    return scripts.remove(queue, job.jobId)\n      .then(function() {\n        queue.emit('removed', job.toJSON());\n      })\n      .finally(function () {\n        return job.releaseLock();\n      });\n  });\n};\n\n/**\n * Returns a promise the resolves when the job has been finished.\n * TODO: Add a watchdog to check if the job has finished periodically.\n * since pubsub does not give any guarantees.\n */\nJob.prototype.finished = function(){\n  var _this = this;\n\n  function status(resolve, reject){\n    return _this.isCompleted().then(function(completed){\n      if(!completed){\n        return _this.isFailed().then(function(failed){\n          if(failed){\n            return Job.fromId(_this.queue, _this.jobId, 'failedReason').then(function(data){\n              reject(Error(data.failedReason));\n              return true;\n            });\n          }\n        });\n      }\n      resolve();\n      return true;\n    });\n  }\n\n  return new Promise(function(resolve, reject){\n    status(resolve, reject).then(function(finished){\n      if(!finished){\n        var interval;\n        function onCompleted(job){\n          if(String(job.jobId) === String(_this.jobId)){\n            resolve();\n            removeListeners();\n            clearInterval(interval);\n          }\n        }\n\n        function onFailed(job, err){\n          if(String(job.jobId) === String(_this.jobId)){\n            reject(err);\n            removeListeners();\n            clearInterval(interval);\n          }\n        }\n\n        function removeListeners(){\n          _this.queue.removeListener('completed', onCompleted);\n          _this.queue.removeListener('failed', onFailed);\n        }\n\n        _this.queue.on('completed', onCompleted);\n        _this.queue.on('failed', onFailed);\n\n        //\n        // Watchdog\n        //\n        interval = setInterval(function(){\n          status(resolve, reject).then(function(finished){\n            if(finished){\n              removeListeners();\n              clearInterval(interval );\n            }\n          })\n        }, 5000);\n      };\n    });\n  });\n}\n\n// -----------------------------------------------------------------------------\n// Private methods\n// -----------------------------------------------------------------------------\nJob.prototype._isDone = function(list){\n  return this.queue.client\n    .sismember(this.queue.toKey(list), this.jobId).then(function(isMember){\n      return isMember === 1;\n    });\n};\n\nJob.prototype._isInList = function(list) {\n  return scripts.isJobInList(this.queue.client, this.queue.toKey(list), this.jobId);\n};\n\nJob.prototype._moveToSet = function(set, context){\n  var queue = this.queue;\n  var jobId = this.jobId;\n\n  return scripts.moveToSet(queue, set, jobId, context);\n};\n\nJob.prototype._getBackOff = function() {\n  var backoff = 0;\n  var delay;\n  if(this.opts.backoff){\n    if(!isNaN(this.opts.backoff)){\n      backoff = this.opts.backoff;\n    }else if(this.opts.backoff.type === 'fixed'){\n      backoff = this.opts.backoff.delay;\n    }else if(this.opts.backoff.type === 'exponential'){\n      delay = this.opts.backoff.delay;\n      backoff = Math.round((Math.pow(2, this.attemptsMade) - 1) * delay);\n    }\n  }\n  return backoff;\n};\n\nJob.prototype._retryAtOnce = function(){\n  var queue = this.queue;\n  var jobId = this.jobId;\n\n  var script = [\n    'if redis.call(\"EXISTS\", KEYS[3]) == 1 then',\n    ' redis.call(\"LREM\", KEYS[1], 0, ARGV[2])',\n    ' redis.call(ARGV[1], KEYS[2], ARGV[2])',\n    ' return 0',\n    'else',\n    ' return -1',\n    'end'\n  ].join('\\n');\n\n  var keys = _.map(['active', 'wait', jobId], function(name){\n    return queue.toKey(name);\n  });\n\n  var pushCmd = (this.opts.lifo ? 'R' : 'L') + 'PUSH';\n\n  return queue.client.eval(\n    script,\n    keys.length,\n    keys[0],\n    keys[1],\n    keys[2],\n    pushCmd,\n    jobId).then(function(result){\n      if(result === -1){\n        throw new Error('Missing Job ' + jobId + ' during retry');\n      }\n    });\n};\n\nJob.prototype._saveAttempt = function(err){\n  if(isNaN(this.attemptsMade)){\n    this.attemptsMade = 1;\n  }else{\n    this.attemptsMade++;\n  }\n  var params = {\n    attemptsMade: this.attemptsMade\n  };\n\n  this.stacktrace.push(err.stack);\n  params.stacktrace = JSON.stringify(this.stacktrace);\n\n  params.failedReason = err.message;\n\n  return this.queue.client.hmset(this.queue.toKey(this.jobId), params);\n};\n\n/**\n*/\nJob.fromData = function(queue, jobId, data){\n  var job = new Job(queue, JSON.parse(data.data), JSON.parse(data.opts));\n  job.jobId = jobId;\n  job._progress = parseInt(data.progress);\n  job.delay = parseInt(data.delay);\n  job.timestamp = parseInt(data.timestamp);\n\n  job.failedReason = data.failedReason;\n  job.attempts = parseInt(data.attempts);\n  if(isNaN(job.attempts)) {\n    job.attempts = 1; // Default to 1 try for legacy jobs\n  }\n  job.attemptsMade = parseInt(data.attemptsMade);\n  var _traces;\n  try{\n    _traces = JSON.parse(data.stacktrace);\n    if(!(_traces instanceof Array)){\n      _traces = [];\n    }\n  }catch (err){\n    _traces = [];\n  }\n\n  job.stacktrace = _traces;\n  try{\n    job.returnvalue = JSON.parse(data.returnvalue);\n  }catch (e){\n    //swallow exception because the returnvalue got corrupted somehow.\n    debuglog('corrupted returnvalue: ' + data.returnvalue, e);\n  }\n  return job;\n};\n\nJob.fromJSON = function(queue, json){\n  var job = new Job(queue, json.data, json.opts);\n  job.jobId = json.opts.jobId;\n  job._progress = parseInt(json.progress);\n  job.delay = parseInt(json.delay);\n  job.timestamp = parseInt(json.timestamp);\n  job.attempts = parseInt(json.attempts);\n  if(isNaN(job.attempts)) {\n    job.attempts = 1; // Default to 1 try for legacy jobs\n  }\n  job.attemptsMade = parseInt(json.attemptsMade);\n  var _traces;\n  try{\n    _traces = JSON.parse(json.stacktrace);\n    if(!(_traces instanceof Array)){\n      _traces = [];\n    }\n  }catch (err){\n    _traces = [];\n  }\n\n  job.stacktrace = _traces;\n  try{\n    job.returnvalue = JSON.parse(json.returnvalue);\n  }catch (e){\n    //swallow exception because the returnvalue got corrupted somehow.\n    debuglog('corrupted returnvalue: ' + json.returnvalue, e);\n  }\n  return job;\n}\n\nmodule.exports = Job;\n","/home/travis/build/npmtest/node-npmtest-bull/node_modules/bull/lib/scripts.js":"/**\n * Includes all the scripts needed by the queue and jobs.\n *\n *\n */\n/*eslint-env node */\n/*global Promise:true */\n'use strict';\n\nvar Promise = require('bluebird');\nvar _ = require('lodash');\nvar debuglog = require('debuglog')('bull');\nvar Redlock = require('bull-redlock');\n\nfunction execScript(client, hash, lua, numberOfKeys){\n    var args = _.drop(arguments, 4);\n\n    debuglog(lua, args);\n\n    if(!client[hash]){\n      client.defineCommand(hash, { numberOfKeys: numberOfKeys, lua: lua });\n    }\n\n    return client[hash](args);\n}\n\nfunction isCommandDefined(client, hash){\n  return !!client[hash];\n}\n\nvar scripts = {\n  _isJobInList: function(keyVar, argVar, operator) {\n   \tkeyVar = keyVar || 'KEYS[1]';\n    argVar = argVar || 'ARGV[1]';\n    operator = operator || 'return';\n    return [\n      'local function item_in_list (list, item)',\n      '  for _, v in pairs(list) do',\n      '    if v == item then',\n      '      return 1',\n      '    end',\n      '  end',\n      '  return nil',\n      'end',\n      ['local items = redis.call(\"LRANGE\",', keyVar, ' , 0, -1)'].join(''),\n      [operator, ' item_in_list(items, ', argVar, ')'].join('')\n    ].join('\\n');\n  },\n  isJobInList: function(client, listKey, jobId){\n    return execScript(client, 'isJobInList', this._isJobInList(), 1, listKey, jobId).then(function(result){\n      return result === 1;\n    });\n  },\n  addJob: function(client, toKey, job, opts){\n    var delayed;\n    var scriptName;\n\n    opts = opts || {};\n    opts.lifo = !!(opts.lifo);\n\n    var delayTimestamp = job.timestamp + job.delay;\n    if(job.delay && delayTimestamp > Date.now()){\n      delayed = true;\n      scriptName = 'addJob:delayed';\n    } else {\n      scriptName = 'addJob'+(opts.lifo?':lifo':'') + (opts.priority?':priority':'');\n    }\n\n    /*\n    if(isCommandDefined(client, scriptName)){\n      return client[scriptName].apply(client, args);\n    };\n    */\n\n    var jobArgs = _.flatten(_.toPairs(job));\n\n    var keys = _.map(['wait', 'paused', 'meta-paused', 'jobs', 'id', 'delayed', 'priority'], function(name){\n      return toKey(name);\n    });\n    var baseKey = toKey('');\n\n    var argvs = _.map(jobArgs, function(arg, index){\n      return ', ARGV['+(index+4)+']';\n    })\n\n    var script = [\n      'local jobCounter = redis.call(\"INCR\", KEYS[5])',\n      'local jobId',\n      'if ARGV[2] == \"\" then jobId = jobCounter else jobId = ARGV[2] end',\n      'local jobIdKey = ARGV[1] .. jobId',\n      'if redis.call(\"EXISTS\", jobIdKey) == 1 then return jobId end',\n      'redis.call(\"HMSET\", jobIdKey' + argvs.join('') + ')',\n    ];\n\n    var delayTimestamp = job.timestamp + job.delay;\n    if(delayed){\n      script.push.apply(script, [\n        ' local timestamp = tonumber(ARGV[' + (argvs.length + 4) + ']) * 0x1000 + bit.band(jobCounter, 0xfff)',\n        ' redis.call(\"ZADD\", KEYS[6], timestamp, jobId)',\n        ' redis.call(\"PUBLISH\", KEYS[6], (timestamp / 0x1000))',\n        ' return jobId',\n      ]);\n    }else{\n      var push, pushPaused;\n      var add = _.template('redis.call(\"<%= direction %>\", <%= waitQueue %>, jobId)');\n\n      if(opts.lifo){\n        push = add({direction: 'RPUSH', waitQueue: 'KEYS[1]'});\n        pushPaused = add({direction: 'RPUSH', waitQueue: 'KEYS[2]'});\n      }else if(opts.priority){\n        script.push.apply(script, [\n          ' redis.call(\"ZADD\", KEYS[7], ARGV[3], jobId)',\n          ' local count = redis.call(\"ZCOUNT\", KEYS[7], 0, ARGV[3])',\n        ]);\n\n        var priorityAdd = _.template([\n          ' local len = redis.call(\"LLEN\", <%= waitQueue %>)',\n          ' local id = redis.call(\"LINDEX\", <%= waitQueue %>, len - (count-1))',\n          ' if id then',\n          '   redis.call(\"LINSERT\", <%= waitQueue %>, \"BEFORE\", id, jobId)',\n          ' else',\n          '   redis.call(\"RPUSH\", <%= waitQueue %>, jobId)',\n          ' end',\n        ].join('\\n'));\n\n        push = priorityAdd({waitQueue: 'KEYS[1]'});\n        pushPaused = priorityAdd({waitQueue: 'KEYS[2]'});\n      }else{\n        push = add({direction: 'LPUSH', waitQueue: 'KEYS[1]'});\n        pushPaused = add({direction: 'LPUSH', waitQueue: 'KEYS[2]'});\n      }\n\n      //\n      // Whe check for the meta-paused key to decide if we are paused or not\n      // (since an empty list and !EXISTS are not really the same)\n      script.push.apply(script, [\n        'if redis.call(\"EXISTS\", KEYS[3]) ~= 1 then',\n        push,\n        'else',\n        pushPaused,\n        'end',\n        'redis.call(\"PUBLISH\", KEYS[4], jobId)',\n        'return jobId .. \"\"'\n      ]);\n    }\n\n    var args = [\n      client,\n      scriptName,\n      script.join('\\n'),\n      keys.length\n    ];\n\n    args.push.apply(args, keys);\n    args.push(baseKey);\n    args.push(opts.customJobId || '');\n    args.push(opts.priority);\n    args.push.apply(args, jobArgs);\n    args.push(delayTimestamp);\n\n    return execScript.apply(scripts, args);\n  },\n\n  // TODO: perfect this function so that it can be used instead\n  // of all the specialized functions moveToComplete, etc.\n  move: function(job, src, target){\n    // TODO: Depending on the source we should use LREM, SREM or ZREM.\n    // TODO: Depending on the target we should use LPUSH, SADD, etc.\n    var keys = _.map([\n      src,\n      target,\n      job.jobId\n      ], function(name){\n        return job.queue.toKey(name);\n      }\n    );\n\n    var deleteJob = 'redis.call(\"DEL\", KEYS[3])';\n\n    var moveJob = [\n      'redis.call(\"SADD\", KEYS[2], ARGV[1])',\n      'redis.call(\"HSET\", KEYS[3], \"returnvalue\", ARGV[2])',\n    ].join('\\n');\n\n    var script = [\n      'if redis.call(\"EXISTS\", KEYS[3]) == 1 then', // Make sure job exists\n      ' redis.call(\"LREM\", KEYS[1], -1, ARGV[1])',\n      target ? moveJob : deleteJob,\n      ' return 0',\n      'else',\n      ' return -1',\n      'end'\n    ].join('\\n');\n\n    var args = [\n      job.queue.client,\n      'move' + src + (target ? target : ''),\n      script,\n      keys.length,\n      keys[0],\n      keys[1],\n      keys[2],\n      job.jobId,\n      job.returnvalue ? JSON.stringify(job.returnvalue) : ''\n    ];\n\n    var returnLockOrErrorCode = function(lock) {\n      return lock ? execScript.apply(scripts, args) : -2;\n    };\n    var throwUnexpectedErrors = function(err) {\n      if (!(err instanceof Redlock.LockError)) {\n        throw err;\n      }\n    };\n\n    return job.takeLock(!!job.lock)\n    .then(returnLockOrErrorCode, throwUnexpectedErrors)\n    .then(function(result){\n      switch (result){\n        case -1:\n          if(src){\n            throw new Error('Missing Job ' + job.jobId + ' when trying to move from ' + src + ' to ' + target);\n          } else {\n            throw new Error('Missing Job ' + job.jobId + ' when trying to remove it from ' + src);\n          }\n        case -2:\n          throw new Error('Cannot get lock for job ' + job.jobId + ' when trying to move from ' + src);\n        default:\n          return job.releaseLock()\n      }\n    });\n  },\n  moveToCompleted: function(job, removeOnComplete){\n    return scripts.move(job, 'active', removeOnComplete ? void 0 : 'completed');\n  },\n\n  moveToSet: function(queue, set, jobId, context){\n    //\n    // Bake in the job id first 12 bits into the timestamp\n    // to guarantee correct execution order of delayed jobs\n    // (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)\n    //\n    // WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail\n    //\n    context = _.isUndefined(context) ? 0 : context;\n\n    if(set === 'delayed') {\n      context = +context || 0;\n      context = context < 0 ? 0 : context;\n      if(context > 0){\n        context = context * 0x1000 + (jobId & 0xfff);\n      }\n    }\n\n    var keys = _.map([\n      'active',\n      set,\n      jobId\n      ], function(name){\n        return queue.toKey(name);\n      }\n    );\n\n    var args = [\n      queue.client,\n      'moveToSet',\n      moveToSetScript,\n      keys.length,\n      keys[0],\n      keys[1],\n      keys[2],\n      JSON.stringify(context),\n      jobId\n    ];\n\n    return execScript.apply(scripts, args).then(function(result){\n      if(result === -1){\n        throw new Error('Missing Job ' + jobId + ' when trying to move from active to ' + set);\n      }\n    });\n  },\n  remove: function(queue, jobId){\n    var script = [\n      'redis.call(\"LREM\", KEYS[1], 0, ARGV[1])',\n      'redis.call(\"LREM\", KEYS[2], 0, ARGV[1])',\n      'redis.call(\"ZREM\", KEYS[3], ARGV[1])',\n      'redis.call(\"LREM\", KEYS[4], 0, ARGV[1])',\n      'redis.call(\"SREM\", KEYS[5], ARGV[1])',\n      'redis.call(\"SREM\", KEYS[6], ARGV[1])',\n      'redis.call(\"DEL\", KEYS[7])'].join('\\n');\n\n    var keys = _.map([\n      'active',\n      'wait',\n      'delayed',\n      'paused',\n      'completed',\n      'failed',\n      jobId], function(name){\n        return queue.toKey(name);\n      }\n    );\n\n    var args = [\n      queue.client,\n      'remove',\n      script,\n      keys.length,\n      keys[0],\n      keys[1],\n      keys[2],\n      keys[3],\n      keys[4],\n      keys[5],\n      keys[6],\n      jobId\n    ];\n\n    return execScript.apply(scripts, args);\n  },\n\n  /**\n   * Gets a lock for a job.\n   *\n   * @param {Queue} queue The queue for the job\n   * @param {Job} job The job\n   * @param {Boolean=false} renew Whether to renew to lock, meaning it will assume the job\n   *    is already locked and just reset the lock expiration.\n   * @param {Boolean=false} ensureActive Ensures that the job is in the 'active' state.\n   */\n  takeLock: function(queue, job, renew, ensureActive){\n    var lock = job.lock;\n    if (renew && !lock) {\n      throw new Error('Unable to renew nonexisting lock');\n    }\n    if (renew) {\n      return lock.extend(queue.LOCK_DURATION);\n    }\n    if (lock) {\n      return Promise.resolve(lock);\n    }\n\n    var redlock;\n    if (ensureActive) {\n      var isJobInList = this._isJobInList('KEYS[2]', 'ARGV[3]', 'if');\n      var lockAcquired = ['and redis.call(\"HSET\", KEYS[3], \"lockAcquired\", \"1\")'].join('');\n      var success = 'then return 1 else return 0 end';\n      var opts = {\n        lockScript: function(lockScript) {\n          return [\n            isJobInList,\n            lockScript.replace('return', 'and'),\n            lockAcquired,\n            success\n          ].join('\\n');\n        },\n        extraLockKeys: [job.queue.toKey('active'), queue.toKey(job.jobId)],\n        extraLockArgs: [job.jobId]\n      };\n      redlock = new Redlock(queue.clients, _.extend(opts, queue.redlock));\n    } else {\n      redlock = new Redlock(queue.clients, queue.redlock);\n    }\n\n    return redlock.lock(job.lockKey(), queue.LOCK_DURATION).catch(function(err){\n      //\n      // Failing to lock due to already locked is not an error.\n      //\n      if(err.name != 'LockError'){\n        throw err;\n      }\n    });\n  },\n\n  releaseLock: function(job){\n    var lock = job.lock;\n    if (!lock) {\n      throw new Error('Unable to release nonexisting lock');\n    }\n    return lock.unlock()\n  },\n  /**\n    It checks if the job in the top of the delay set should be moved back to the\n    top of the  wait queue (so that it will be processed as soon as possible)\n  */\n  updateDelaySet: function(queue, delayedTimestamp){\n    var script = [\n      'local RESULT = redis.call(\"ZRANGE\", KEYS[1], 0, 0, \"WITHSCORES\")',\n      'local jobId = RESULT[1]',\n      'local score = RESULT[2]',\n      'if (score ~= nil) then',\n      ' score = score / 0x1000 ',\n      ' if (score <= tonumber(ARGV[2])) then',\n      '  redis.call(\"ZREM\", KEYS[1], jobId)',\n      '  redis.call(\"LREM\", KEYS[2], 0, jobId)',\n      '  redis.call(\"LPUSH\", KEYS[3], jobId)',\n      '  redis.call(\"PUBLISH\", KEYS[4], jobId)',\n      '  redis.call(\"HSET\", ARGV[1] .. jobId, \"delay\", 0)',\n      '  local nextTimestamp = redis.call(\"ZRANGE\", KEYS[1], 0, 0, \"WITHSCORES\")[2]',\n      '  if(nextTimestamp ~= nil) then',\n      '   nextTimestamp = nextTimestamp / 0x1000',\n      '   redis.call(\"PUBLISH\", KEYS[1], nextTimestamp)',\n      '  end',\n      '  return nextTimestamp',\n      ' end',\n      ' return score',\n      'end'].join('\\n');\n\n    var keys = _.map([\n      'delayed',\n      'active',\n      'wait',\n      'jobs'], function(name){\n        return queue.toKey(name);\n    });\n\n    var args = [\n      queue.client,\n      'updateDelaySet',\n      script,\n      keys.length,\n      keys[0],\n      keys[1],\n      keys[2],\n      keys[3],\n      queue.toKey(''),\n      delayedTimestamp\n    ];\n\n    return execScript.apply(scripts, args);\n  },\n\n  /**\n   * Looks for unlocked jobs in the active queue. There are two circumstances in which a job\n   * would be in 'active' but NOT have a job lock:\n   *\n   *  Case A) The job was being worked on, but the worker process died and it failed to renew the lock.\n   *    We call these jobs 'stalled'. This is the most common case. We resolve these by moving them\n   *    back to wait to be re-processed. To prevent jobs from cycling endlessly between active and wait,\n   *    (e.g. if the job handler keeps crashing), we limit the number stalled job recoveries to MAX_STALLED_JOB_COUNT.\n\n   *  Case B) The job was just moved to 'active' from 'wait' and the worker that moved it hasn't gotten\n   *    a lock yet, or died immediately before getting the lock (note that due to Redis limitations, the\n   *    worker can't move the job and get the lock atomically - https://github.com/OptimalBits/bull/issues/258).\n   *    For this case we also move the job back to 'wait' for reprocessing, but don't consider it 'stalled'\n   *    since the job had never been started. This case is much rarer than Case A due to the very small\n   *    timing window in which it must occur.\n   */\n  moveUnlockedJobsToWait: function(queue){\n    var script = [\n      'local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])',\n      'local activeJobs = redis.call(\"LRANGE\", KEYS[1], 0, -1)',\n      'local stalled = {}',\n      'local failed = {}',\n      'for _, job in ipairs(activeJobs) do',\n      ' local jobKey = ARGV[2] .. job',\n      ' if(redis.call(\"EXISTS\", jobKey .. \":lock\") == 0) then',\n      //  Remove from the active queue.\n      '   redis.call(\"LREM\", KEYS[1], 1, job)',\n      '   local lockAcquired = redis.call(\"HGET\", jobKey, \"lockAcquired\")',\n      '   if(lockAcquired) then',\n      //    If it was previously locked then we consider it 'stalled' (Case A above). If this job\n      //    has been stalled too many times, such as if it crashes the worker, then fail it.\n      '     local stalledCount = redis.call(\"HINCRBY\", jobKey, \"stalledCounter\", 1)',\n      '     if(stalledCount > MAX_STALLED_JOB_COUNT) then',\n      '       redis.call(\"SADD\", KEYS[3], job)',\n      '       redis.call(\"HSET\", jobKey, \"failedReason\", \"job stalled more than allowable limit\")',\n      '       table.insert(failed, job)',\n      '     else',\n      //      Move the job back to the wait queue, to immediately be picked up by a waiting worker.\n      '       redis.call(\"RPUSH\", KEYS[2], job)',\n      '       table.insert(stalled, job)',\n      '     end',\n      '   else',\n      //    Move the job back to the wait queue, to immediately be picked up by a waiting worker.\n      '     redis.call(\"RPUSH\", KEYS[2], job)',\n      '   end',\n      ' end',\n      'end',\n      'return {failed, stalled}'\n    ].join('\\n');\n\n    var args = [\n      queue.client,\n      'moveUnlockedJobsToWait',\n      script,\n      3,\n      queue.toKey('active'),\n      queue.toKey('wait'),\n      queue.toKey('failed'),\n      queue.MAX_STALLED_JOB_COUNT,\n      queue.toKey('')\n    ];\n\n    return execScript.apply(scripts, args);\n  },\n\n  cleanJobsInSet: function(queue, set, ts, limit) {\n    var command;\n    var removeCommand;\n    var breakEarlyCommand = '';\n    var hash;\n    limit = limit || 0;\n\n    switch(set) {\n      case 'completed':\n      case 'failed':\n        command = 'local jobs = redis.call(\"SMEMBERS\", KEYS[1])';\n        removeCommand = 'redis.call(\"SREM\", KEYS[1], job)';\n        hash = 'cleanSet';\n        break;\n      case 'wait':\n      case 'active':\n      case 'paused':\n        command = 'local jobs = redis.call(\"LRANGE\", KEYS[1], 0, -1)';\n        removeCommand = 'redis.call(\"LREM\", KEYS[1], 0, job)';\n        hash = 'cleanList';\n        break;\n      case 'delayed':\n        command = 'local jobs = redis.call(\"ZRANGE\", KEYS[1], 0, -1)';\n        removeCommand = 'redis.call(\"ZREM\", KEYS[1], job)';\n        hash = 'cleanOSet';\n        break;\n    }\n\n    if(limit > 0) {\n      breakEarlyCommand = [\n        'if deletedCount >= limit then',\n        '  break',\n        'end',\n      ].join('\\n');\n\n      hash = hash + 'WithLimit';\n    }\n\n    var script = [\n      command,\n      'local deleted = {}',\n      'local deletedCount = 0',\n      'local limit = tonumber(ARGV[3])',\n      'local jobTS',\n      'for _, job in ipairs(jobs) do',\n      breakEarlyCommand,\n      '  local jobKey = ARGV[1] .. job',\n      '  if (redis.call(\"EXISTS\", jobKey ..  \":lock\") == 0) then',\n      '    jobTS = redis.call(\"HGET\", jobKey, \"timestamp\")',\n      '    if(not jobTS or jobTS < ARGV[2]) then',\n      removeCommand,\n      '      redis.call(\"DEL\", jobKey)',\n      '      deletedCount = deletedCount + 1',\n      '      table.insert(deleted, job)',\n      '    end',\n      '  end',\n      'end',\n      'return deleted'\n    ].join('\\n');\n\n    var args = [\n      queue.client,\n      hash,\n      script,\n      1,\n      queue.toKey(set),\n      queue.toKey(''),\n      ts,\n      limit\n    ];\n\n    return execScript.apply(scripts, args);\n  },\n\n  /**\n   * Attempts to reprocess a job\n   *\n   * @param {Job} job\n   * @param {Object} options\n   * @param {String} options.state The expected job state. If the job is not found\n   * on the provided state, then it's not reprocessed. Supported states: 'failed', 'completed'\n   *\n   * @return {Promise<Number>} Returns a promise that evaluates to a return code:\n   * 1 means the operation was a success\n   * 0 means the job does not exist\n   * -1 means the job is currently locked and can't be retried.\n   * -2 means the job was not found in the expected set\n   */\n  reprocessJob: function(job, options) {\n    var push = (job.opts.lifo ? 'R' : 'L') + 'PUSH';\n\n    var script = [\n      'if (redis.call(\"EXISTS\", KEYS[1]) == 1) then',\n      '  if (redis.call(\"EXISTS\", KEYS[2]) == 0) then',\n      '    if (redis.call(\"SREM\", KEYS[3], ARGV[1]) == 1) then',\n      '      redis.call(\"' + push + '\", KEYS[4], ARGV[1])',\n      '      redis.call(\"PUBLISH\", KEYS[5], ARGV[1])',\n      '      return 1',\n      '    else',\n      '      return -2',\n      '    end',\n      '  else',\n      '    return -1',\n      '  end',\n      'else',\n      '  return 0',\n      'end'\n    ].join('\\n');\n\n    var queue = job.queue;\n\n    var keys = [\n      queue.toKey(job.jobId),\n      queue.toKey(job.jobId) + ':lock',\n      queue.toKey(options.state),\n      queue.toKey('wait'),\n      queue.toKey('jobs')\n    ];\n\n    var args = [\n      queue.client,\n      'retryJob',\n      script,\n      5,\n      keys[0],\n      keys[1],\n      keys[2],\n      keys[3],\n      keys[4],\n      job.jobId\n    ];\n\n    return execScript.apply(scripts, args);\n  }\n};\n\n/*\nQueue.prototype.empty = function(){\n  var _this = this;\n\n  // Get all jobids and empty all lists atomically.\n  var multi = this.multi();\n\n  multi.lrange(this.toKey('wait'), 0, -1);\n  multi.lrange(this.toKey('paused'), 0, -1);\n  multi.del(this.toKey('wait'));\n  multi.del(this.toKey('paused'));\n  multi.del(this.toKey('meta-paused'));\n  multi.del(this.toKey('delayed'));\n\n  return multi.exec().spread(function(waiting, paused){\n    var jobKeys = (paused.concat(waiting)).map(_this.toKey, _this);\n\n    if(jobKeys.length){\n      multi = _this.multi();\n\n      multi.del.apply(multi, jobKeys);\n      return multi.exec();\n    }\n  });\n};\n*/\n/**\n * KEYS:\n * 0 - wait\n * 1 - paused\n * 2 - meta-paused\n * 3 - delayed\n */\nvar emptyScript = [\n\n]\n\n  // this lua script takes three keys and two arguments\n  // keys:\n  //  - the expanded key for the active set\n  //  - the expanded key for the destination set\n  //  - the expanded key for the job\n  //\n  // arguments:\n  //  - json serialized context which is:\n  //     - delayedTimestamp when the destination set is 'delayed'\n  //     - stacktrace when the destination set is 'failed'\n  //     - returnvalue of the handler when the destination set is 'completed'\n  //  - the id of the job\n  //\n  // it checks whether KEYS[2] the destination set ends with 'delayed', 'completed'\n  // or 'failed'. And then adds the context to the jobhash and adds the job to\n  // the destination set. Finally it removes the job from the active list.\n  //\n  // it returns either 0 for success or -1 for failure.\nvar moveToSetScript = [\n  'if redis.call(\"EXISTS\", KEYS[3]) == 1 then',\n  ' if string.find(KEYS[2], \"delayed$\") ~= nil then',\n  ' local score = tonumber(ARGV[1])',\n  '  if score ~= 0 then',\n  '   redis.call(\"ZADD\", KEYS[2], score, ARGV[2])',\n  '   redis.call(\"PUBLISH\", KEYS[2], (score / 0x1000))',\n  '  else',\n  '   redis.call(\"SADD\", KEYS[2], ARGV[2])',\n  '  end',\n  ' elseif string.find(KEYS[2], \"completed$\") ~= nil then',\n  '  redis.call(\"HSET\", KEYS[3], \"returnvalue\", ARGV[1])',\n  '  redis.call(\"SADD\", KEYS[2], ARGV[2])',\n  ' elseif string.find(KEYS[2], \"failed$\") ~= nil then',\n  '  redis.call(\"SADD\", KEYS[2], ARGV[2])',\n  ' else',\n  '  return -1',\n  ' end',\n  ' redis.call(\"LREM\", KEYS[1], 0, ARGV[2])',\n  ' return 0',\n  'else',\n  ' return -1',\n  'end'\n  ].join('\\n');\n\nmodule.exports = scripts;\n","/home/travis/build/npmtest/node-npmtest-bull/node_modules/bull-redlock/redlock.js":"'use strict';\n\nvar util         = require('util');\nvar crypto       = require('crypto');\nvar Promise      = require('bluebird');\nvar EventEmitter = require('events');\n\n// support the event library provided by node < 0.11.0\nif(typeof EventEmitter.EventEmitter === 'function')\n\tEventEmitter = EventEmitter.EventEmitter;\n\n\n// constants\nvar lockScript = 'return redis.call(\"set\", KEYS[1], ARGV[1], \"NX\", \"PX\", ARGV[2])';\nvar unlockScript = 'if redis.call(\"get\", KEYS[1]) == ARGV[1] then return redis.call(\"del\", KEYS[1]) else return 0 end';\nvar extendScript = 'if redis.call(\"get\", KEYS[1]) == ARGV[1] then return redis.call(\"pexpire\", KEYS[1], ARGV[2]) else return 0 end';\n\n// defaults\nvar defaults = {\n\tdriftFactor: 0.01,\n\tretryCount:  10,\n\tretryDelay:  400,\n\tretryJitter: 400\n};\n\n\n\n\n\n// LockError\n// ---------\n// This error is returned when there is an error locking a resource.\nfunction LockError(message) {\n\tError.call(this);\n\tError.captureStackTrace(this, LockError);\n\tthis.name = 'LockError';\n\tthis.message = message || 'Failed to lock the resource.';\n}\n\nutil.inherits(LockError, Error);\n\n\n\n\n\n\n// Lock\n// ----\n// An object of this type is returned when a resource is successfully locked. It contains\n// convenience methods `unlock` and `extend` which perform the associated Redlock method on\n// itself.\nfunction Lock(redlock, resource, value, expiration) {\n\tthis.redlock    = redlock;\n\tthis.resource   = resource;\n\tthis.value      = value;\n\tthis.expiration = expiration;\n}\n\nLock.prototype.unlock = function unlock(callback) {\n\treturn this.redlock.unlock(this, callback);\n};\n\nLock.prototype.extend = function extend(ttl, callback) {\n\treturn this.redlock.extend(this, ttl, callback);\n};\n\n// Attach a reference to Lock, which allows the application to use instanceof\n// to ensure type.\nRedlock.Lock = Lock;\n\n\n\n\n\n// Redlock\n// -------\n// A redlock object is instantiated with an array of at least one redis client and an optional\n// `options` object. Properties of the Redlock object should NOT be changed after it is first\n// used, as doing so could have unintended consequences for live locks.\nfunction Redlock(clients, options) {\n\t// set default options\n\toptions = options || {};\n\tthis.driftFactor  = typeof options.driftFactor  === 'number' ? options.driftFactor : defaults.driftFactor;\n\tthis.retryCount   = typeof options.retryCount   === 'number' ? options.retryCount  : defaults.retryCount;\n\tthis.retryDelay   = typeof options.retryDelay   === 'number' ? options.retryDelay  : defaults.retryDelay;\n\tthis.retryJitter  = typeof options.retryJitter  === 'number' ? options.retryJitter  : defaults.retryJitter;\n\tthis.lockScript   = typeof options.lockScript   === 'function' ? options.lockScript(lockScript) : lockScript;\n\tthis.unlockScript = typeof options.unlockScript === 'function' ? options.unlockScript(unlockScript) : unlockScript;\n\tthis.extendScript = typeof options.extendScript === 'function' ? options.extendScript(extendScript) : extendScript;\n\n\tthis.extraLockKeys = options.extraLockKeys;\n\tthis.extraLockArgs = options.extraLockArgs;\n\n\t// set the redis servers from additional arguments\n\tthis.servers = clients;\n\tif(this.servers.length === 0)\n\t\tthrow new Error('Redlock must be instantiated with at least one redis server.');\n}\n\n// Inherit all the EventEmitter methods, like `on`, and `off`\nutil.inherits(Redlock, EventEmitter);\n\n\n// Attach a reference to LockError per issue #7, which allows the application to use instanceof\n// to destinguish between error types.\nRedlock.LockError = LockError;\n\n\n// lock\n// ----\n// This method locks a resource using the redlock algorithm.\n//\n// ```js\n// redlock.lock(\n//   'some-resource',       // the resource to lock\n//   2000,                  // ttl in ms\n//   function(err, lock) {  // callback function (optional)\n//     ...\n//   }\n// )\n// ```\nRedlock.prototype.acquire =\nRedlock.prototype.lock = function lock(resource, ttl, callback) {\n\treturn this._lock(resource, null, ttl, callback);\n};\n\n// lock\n// ----\n// This method locks a resource using the redlock algorithm,\n// and returns a bluebird disposer.\n//\n// ```js\n// using(\n//   redlock.disposer(\n//     'some-resource',       // the resource to lock\n//     2000                   // ttl in ms\n//   ),\n//   function(lock) {\n//     ...\n//   }\n// );\n// ```\nRedlock.prototype.disposer = function disposer(resource, ttl, errorHandler) {\n\terrorHandler = errorHandler || function(err) {};\n\treturn this._lock(resource, null, ttl).disposer(function(lock){\n\t\treturn lock.unlock().catch(errorHandler);\n\t});\n};\n\n\n// unlock\n// ------\n// This method unlocks the provided lock from all servers still persisting it. It will fail\n// with an error if it is unable to release the lock on a quorum of nodes, but will make no\n// attempt to restore the lock on nodes that failed to release. It is safe to re-attempt an\n// unlock or to ignore the error, as the lock will automatically expire after its timeout.\nRedlock.prototype.release =\nRedlock.prototype.unlock = function unlock(lock, callback) {\n\tvar self = this;\n\treturn new Promise(function(resolve, reject) {\n\n\t\t// immediately invalidate the lock\n\t\tlock.expiration = 0;\n\n\t\t// the number of servers which have agreed to release this lock\n\t\tvar votes = 0;\n\n\t\t// the number of votes needed for consensus\n\t\tvar quorum = Math.floor(self.servers.length / 2) + 1;\n\n\t\t// the number of async redis calls still waiting to finish\n\t\tvar waiting = self.servers.length;\n\n\t\t// release the lock on each server\n\t\tself.servers.forEach(function(server){\n\t\t\tserver.eval(self.unlockScript, 1, lock.resource, lock.value, loop);\n\t\t});\n\n\t\tfunction loop(err, response) {\n\t\t\tif(err) self.emit('clientError', err);\n\n\t\t\t// - if the lock was released by this call, it will return 1\n\t\t\t// - if the lock has already been released, it will return 0\n\t\t\t//    - it may have been re-acquired by another process\n\t\t\t//    - it may hava already been manually released\n\t\t\t//    - it may have expired\n\t\t\tif(typeof response === 'number' && (response === 0 || response === 1))\n\t\t\t\tvotes++;\n\n\t\t\tif(waiting-- > 1) return;\n\n\t\t\t// SUCCESS: there is concensus and the lock is released\n\t\t\tif(votes >= quorum)\n\t\t\t\treturn resolve();\n\n\t\t\t// FAILURE: the lock could not be released\n\t\t\treturn reject(new LockError('Unable to fully release the lock on resource \"' + lock.resource + '\".'));\n\t\t}\n\t})\n\n\t// optionally run callback\n\t.nodeify(callback);\n};\n\n\n// extend\n// ------\n// This method extends a valid lock by the provided `ttl`.\nRedlock.prototype.extend = function extend(lock, ttl, callback) {\n\tvar self = this;\n\n\t// the lock has expired\n\tif(lock.expiration < Date.now())\n\t\treturn Promise.reject(new LockError('Cannot extend lock on resource \"' + lock.resource + '\" because the lock has already expired.')).nodeify(callback);\n\n\t// extend the lock\n\treturn self._lock(lock.resource, lock.value, ttl)\n\n\t// modify and return the original lock object\n\t.then(function(extension){\n\t\tlock.value      = extension.value;\n\t\tlock.expiration = extension.expiration;\n\t\treturn lock;\n\t})\n\n\t// optionally run callback\n\t.nodeify(callback);\n};\n\n\n// _lock\n// -----\n// This method locks a resource using the redlock algorithm.\n//\n// ###Creating New Locks:\n//\n// ```js\n// redlock._lock(\n//   'some-resource',       // the resource to lock\n//   null,                  // no original lock value\n//   2000,                  // ttl in ms\n//   function(err, lock) {  // callback function (optional)\n//     ...\n//   }\n// )\n// ```\n//\n// ###Extending Existing Locks:\n//\n// ```js\n// redlock._lock(\n//   'some-resource',       // the resource to lock\n//   'dkkk18g4gy39dx6r',    // the value of the original lock\n//   2000,                  // ttl in ms\n//   function(err, lock) {  // callback function (optional)\n//     ...\n//   }\n// )\n// ```\nRedlock.prototype._lock = function _lock(resource, value, ttl, callback) {\n\tvar self = this;\n\treturn new Promise(function(resolve, reject) {\n\t\tvar request;\n\n\t\t// the number of times we have attempted this lock\n\t\tvar attempts = 0;\n\n\t\t// create a new lock\n\t\tif(value === null) {\n\t\t\tvalue = self._random();\n\t\t\tvar keys = [resource].concat(self.extraLockKeys || []);\n\t\t\tvar args = [value, ttl].concat(self.extraLockArgs || []);\n\t\t\tvar cmd = 'redlockLock' + (self.extraLockKeys ? 'Extra' : '');\n\t\t\trequest = function(server, loop){\n\t\t\t\tif(!server[cmd]){\n\t\t\t\t\tserver.defineCommand(cmd, {\n\t\t\t\t\t\tnumberOfKeys: keys.length,\n\t\t\t\t\t\tlua: self.lockScript\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn server[cmd].apply(server, keys.concat(args).concat([loop]));\n\t\t\t};\n\t\t}\n\n\t\t// extend an existing lock\n\t\telse {\n\t\t\trequest = function(server, loop){\n\t\t\t\treturn server.eval(self.extendScript, 1, resource, value, ttl, loop);\n\t\t\t};\n\t\t}\n\n\t\tfunction attempt(){\n\t\t\tattempts++;\n\n\t\t\t// the time when this attempt started\n\t\t\tvar start = Date.now();\n\n\t\t\t// the number of servers which have agreed to this lock\n\t\t\tvar votes = 0;\n\n\t\t\t// the number of votes needed for consensus\n\t\t\tvar quorum = Math.floor(self.servers.length / 2) + 1;\n\n\t\t\t// the number of async redis calls still waiting to finish\n\t\t\tvar waiting = self.servers.length;\n\n\t\t\tfunction loop(err, response) {\n\t\t\t\tif(err) self.emit('clientError', err);\n\t\t\t\tif(response) votes++;\n\t\t\t\tif(waiting-- > 1) return;\n\n\t\t\t\t// Add 2 milliseconds to the drift to account for Redis expires precision, which is 1 ms,\n\t\t\t\t// plus the configured allowable drift factor\n\t\t\t\tvar drift = Math.round(self.driftFactor * ttl) + 2;\n\t\t\t\tvar lock = new Lock(self, resource, value, start + ttl - drift);\n\n\t\t\t\t// SUCCESS: there is concensus and the lock is not expired\n\t\t\t\tif(votes >= quorum && lock.expiration > Date.now())\n\t\t\t\t\treturn resolve(lock);\n\n\n\t\t\t\t// remove this lock from servers that voted for it\n\t\t\t\treturn lock.unlock(function(){\n\n\t\t\t\t\t// RETRY\n\t\t\t\t\tif(attempts <= self.retryCount)\n\t\t\t\t\t\treturn setTimeout(attempt, self.retryDelay + Math.floor((Math.random() * 2 - 1) * self.retryJitter));\n\n\t\t\t\t\t// FAILED\n\t\t\t\t\treturn reject(new LockError('Exceeded ' + self.retryCount + ' attempts to lock the resource \"' + resource + '\".'));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn self.servers.forEach(function(server){\n\t\t\t\treturn request(server, loop);\n\t\t\t});\n\t\t}\n\n\t\treturn attempt();\n\t})\n\n\t// optionally run callback\n\t.nodeify(callback);\n};\n\n\nRedlock.prototype._random = function _random(){\n\treturn crypto.randomBytes(16).toString('hex');\n};\n\n\nmodule.exports = Redlock;\n","/home/travis/build/npmtest/node-npmtest-bull/node_modules/bull/lib/timer-manager.js":"/*eslint-env node */\n'use strict';\n\nvar Promise = require('bluebird');\nvar _ = require('lodash');\nvar uuid = require('uuid');\n\n/**\n  Timer Manager\n\n  Keep track of timers to ensure that disconnect() is\n  only called (via close()) at a time when it's safe\n  to do so.\n\n  Queues currently use two timers:\n\n    - The first one is used for delayed jobs and is\n    preemptible i.e. it is possible to close a queue\n    while delayed jobs are still pending (they will\n    be processed when the queue is resumed). This timer\n    is cleared by close() and is not managed here.\n\n    - The second one is used to lock Redis while\n    processing jobs. These timers are short-lived,\n    and there can be more than one active at a\n    time.\n\n  The lock timer executes Redis commands, which\n  means we can't close queues while it's active i.e.\n  this won't work:\n\n    queue.process(function (job, jobDone) {\n      handle(job);\n      queue.disconnect().then(jobDone);\n    })\n\n  The disconnect() call closes the Redis connections; then, when\n  a queue tries to perform the scheduled Redis commands,\n  they block until a Redis connection becomes available...\n\n  The solution is to close the Redis connections when there are no\n  active timers i.e. when the queue is idle. This helper class keeps\n  track of the active timers and executes any queued listeners\n  whenever that count goes to zero.\n\n  Since disconnect() simply can't work if there are active handles,\n  its close() wrapper postpones closing the Redis connections\n  until the next idle state. This means that close() can safely\n  be called from anywhere at any time, even from within a job\n  handler:\n\n    queue.process(function (job, jobDone) {\n      handle(job);\n      queue.close();\n      jobDone();\n    })\n*/\n\nfunction TimerManager(){\n  this.idle = true;\n  this.listeners = [];\n  this.timers = {};\n}\n\n/**\n  Create a new timer (setTimeout).\n\n  Expired timers are automatically cleared\n\n  @param {String} name - Name of a timer key. Used only for debugging.\n  @param {Number} delay - delay of timeout\n  @param {Function} fn - Function to execute after delay\n  @returns {Number} id - The timer id. Used to clear the timer\n*/\nTimerManager.prototype.set = function(name, delay, fn){\n  var id = uuid.v4();\n  var now = Date.now();\n  var timer = setTimeout(function (timerInstance, timeoutId) {\n    timerInstance.clear(timeoutId);\n    try{\n      fn();\n    }catch(err){\n      console.error(err);\n    }\n  }, delay, this, id);\n\n  // XXX only the timer is used, but the\n  // other fields are useful for\n  // troubleshooting/debugging\n  this.timers[id] = {\n    name: name,\n    created: now,\n    timer: timer\n  };\n\n  this.idle = false;\n  return id;\n};\n\n/**\n  Clear a timer (clearTimeout).\n\n  Queued listeners are executed if there are no\n  remaining timers\n*/\nTimerManager.prototype.clear = function(id){\n  var timers = this.timers;\n  var timer = timers[id];\n  if(!timer) {\n    return;\n  }\n  clearTimeout(timer.timer);\n  delete timers[id];\n  if(!this.idle && (_.size(timers) === 0)){\n    while(this.listeners.length){\n      this.listeners.pop()();\n    }\n    this.idle = true;\n  }\n};\n\nTimerManager.prototype.clearAll = function(){\n  var _this = this;\n  _.each(this.timers, function(timer, id){\n    _this.clear(id);\n  });\n};\n\n/**\n * Returns a promise that resolves when there are no active timers.\n*/\nTimerManager.prototype.whenIdle = function() {\n  var _this = this;\n  return new Promise(function(resolve){\n    if(_this.idle) {\n      resolve();\n    } else{\n      _this.listeners.unshift(resolve);\n    }\n  });\n};\n\nmodule.exports = TimerManager;\n","/home/travis/build/npmtest/node-npmtest-bull/node_modules/bull/gulpfile.js":"/*eslint-env node */\n'use strict';\n\nvar gulp = require('gulp'),\n  eslint = require('gulp-eslint');\n\ngulp.task('lint', function () {\n  // Note: To have the process exit with an error code (1) on\n  //  lint error, return the stream and pipe to failOnError last.\n  return gulp.src([\n    './lib/job.js',\n    './lib/queue.js',\n    './lib/timer-manager.js',\n    './test/**'\n  ])\n    .pipe(eslint({\n      rules: {\n      //  'keyword-spacing': [2, 'never'],\n        indent: [2, 2, {\"SwitchCase\": 1}],\n        'valid-jsdoc': 0,\n        'func-style': 0,\n        'no-use-before-define': 0,\n        camelcase: 1,\n        'no-unused-vars': 1,\n        'no-alert': 1,\n        'no-console': 1,\n        'quotes': [2, \"single\"],\n        'no-underscore-dangle': 0\n      },\n      globals: {\n        'define': true,\n        'describe': true,\n        'it': true,\n        'setTimeout': true,\n        'after': true,\n        'afterEach': true,\n        'beforeEach': true,\n        'before': true\n      }\n    }))\n    .pipe(eslint.format())\n    .pipe(eslint.failAfterError());\n});\n\ngulp.task('default', ['lint'], function () {\n  // This will only run if the lint task is successful...\n});\n","/home/travis/build/npmtest/node-npmtest-bull/node_modules/bull/lib/cluster-queue.js":"\"use strict\"\n\nvar\n  Queue = require('./queue'),\n  cluster = require('cluster');\n\nvar numWorkers = 8;\nvar queue = Queue(\"test concurrent queue\", 6379, '127.0.0.1');\n\nif(cluster.isMaster){\n  for (var i = 0; i < numWorkers; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('online', function(worker) {\n    // Lets create a few jobs for every created worker\n    for(var i=0; i<500; i++){\n      queue.add({foo: 'bar'});\n    };\n  });\n\n  cluster.on('exit', function(worker, code, signal) {\n    console.log('worker ' + worker.process.pid + ' died');\n  });\n}else{\n  queue.process(function(job, jobDone){\n    console.log(\"Job done by worker\", cluster.worker.id, job.jobId);\n    jobDone();\n  });\n}\n\n","/home/travis/build/npmtest/node-npmtest-bull/node_modules/bull/lib/message.js":"\"use strict\";\nvar redis = require('redis');\nvar when = require('when');\n\n/**\ninterface JobOptions\n{\n  attempts: number;\n}\n*/\n\n// queue: Queue, msgId: string, data: {}, opts: JobOptions\nvar Message = function Message(queue, msgId, data, opts){\n  this.queue = queue;\n  this.msgId = msgId;\n  this.data = data;\n  this.opts = opts;\n  this._progress = 0;\n}\n\nMessage.create = function(queue, msgId, data, opts){\n  var deferred = when.defer();\n  var msg = new Message(queue, msgId, data, opts);\n  queue.client.HMSET(queue.toKey(msgId), msg.toData(), function(err){\n    if(err){\n      deferred.reject(err);\n    }else{\n      deferred.resolve(job);\n    }\n  });\n  return deferred.promise;\n}\n\nMessage.fromId = function(queue, msgId){\n  var deferred = when.defer();\n  queue.client.HGETALL(queue.toKey(msgId), function(err, data){\n    if(data){\n      deferred.resolve(Message.fromData(queue, msgId, data));\n    }else{\n      deferred.reject(err);\n    }\n  });\n  return deferred.promise;\n}\n\nMessage.prototype.toData = function(){\n  return {\n    name: this.name,\n    data: JSON.stringify(this.data || {}),\n    opts: JSON.stringify(this.opts || {}),\n    progress: this._progress\n  }\n}\n\nMessage.prototype.progress = function(progress){\n  if(progress){\n    var deferred = when.defer();\n    var _this = this;\n    this.queue.client.hset(this.queue.toKey(this.msgId), 'progress', progress, function(err){\n      if(err){\n        deferred.reject(err);\n      }else{\n        deferred.resolve();\n        _this.queue.emit('progress', _this, progress);\n      }\n    });\n    return deferred.promise;\n  }else{\n    return this._progress;\n  }\n}\n\nJob.prototype.completed = function(){\n  return this._done('completed');\n}\n\nJob.prototype.failed = function(err){\n  return this._done('failed');\n}\n\nJob.prototype.isCompleted = function(){\n  return this._isDone('completed');\n}\n\nJob.prototype.isFailed = function(){\n  return this._isDone('failed');\n}\n\nJob.prototype._isDone = function(list){\n  var deferred = when.defer();\n  this.queue.client.SISMEMBER(this.queue.toKey(list), this.jobId, function(err, isMember){\n    if(err){\n      deferred.reject(err);\n    }else{\n      deferred.resolve(isMember === 1);\n    }\n  });\n  return deferred.promise;\n}\n\nJob.prototype._done = function(list){\n  var deferred = when.defer();\n  var queue = this.queue;\n  var activeList = queue.toKey('active');\n  var completedList = queue.toKey(list);\n\n  queue.client.multi()\n    .lrem(activeList, 0, this.jobId)\n    .sadd(completedList, this.jobId)\n    .exec(function(err){\n      !err && deferred.resolve();\n      err && deferred.reject(err);\n  });\n  return deferred.promise;\n}\n\n/**\n*/\nJob.fromData = function(queue, jobId, data){\n  var job = new Job(queue, jobId, data.name, JSON.parse(data.data), data.opts);\n  job._progress = parseInt(data.progress);\n  return job;\n}\n\nmodule.exports = Job;\n","/home/travis/build/npmtest/node-npmtest-bull/node_modules/bull/lib/priority-queue.js":"\"use strict\";\n\nvar Queue = require('./queue');\nvar Promise = require(\"bluebird\");\nvar events = require('events');\nvar util = require('util');\n\n/**\n   Priority Queue.\n\n   This is a priority queue based on the normal Queue, to provide the same\n   stability and robustness. The priority queue is in fact several Queues,\n   one for every possible priority.\n*/\nvar PriorityQueue = module.exports = function(name, redisPort, redisHost, redisOptions) {\n  if (!(this instanceof PriorityQueue)) {\n    return new PriorityQueue(name, redisPort, redisHost, redisOptions);\n  }\n\n  console.warn(\"DEPRECATION NOTICE: PriorityQueue has been deprecated and will be removed in bull 3.0.0, please use the priority option instead.\");\n\n  var _this = this;\n  this.paused = false;\n  this.queues = [];\n\n  for (var key in PriorityQueue.priorities) {\n    var queue = Queue(PriorityQueue.getQueueName(name, key), redisPort, redisHost, redisOptions);\n    this.queues[PriorityQueue.priorities[key]] = queue;\n  }\n\n  var groupEvents = ['ready', 'paused', 'resumed']\n  groupEvents.forEach(function(event) {\n    Promise.map(_this.queues, function(queue) {\n      return new Promise(function(resolve, reject) {\n        queue.once(event, resolve);\n      });\n    }).then(_this.emit.bind(_this, event))    \n  })\n\n  var singleEvents = ['error', 'active', 'stalled', 'progress', 'completed', 'failed', 'cleaned']\n  singleEvents.forEach(function(event) {\n    _this.queues.forEach(function(queue) {\n      queue.on(event, _this.emit.bind(_this, event))\n    })\n  })\n\n  this.strategy = Strategy.exponential;\n}\n\nutil.inherits(PriorityQueue, events.EventEmitter);\n\nPriorityQueue.priorities = {\n  low: 0,\n  normal: 1,\n  medium: 2,\n  high: 3,\n  critical: 4\n}\n\nPriorityQueue.getQueueName = function(name, priority) {\n  return name + ':prio:' + priority;\n}\n\n/**\n * Priority queue do not use blocking\n * In order to avoid query redis too much, and to reduce load, we wait a certain time if we loop all queue\n * without processing any job (ie: all are empty)\n *\n * @type {number}\n */\nPriorityQueue.prototype.waitAfterEmptyLoop = 200;\n\nPriorityQueue.prototype.disconnect = function() {\n  return Promise.map(this.queues, function(queue) {\n    return queue.disconnect();\n  })\n}\n\nPriorityQueue.prototype.close = function( doNotWaitJobs ) {\n  return this.closing = Promise.map(this.queues, function(queue) {\n    return queue.close( doNotWaitJobs );\n  });\n}\n\nPriorityQueue.prototype.process = function(handler) {\n  this.handler = handler;\n  this.queues.forEach(function(queue, key) {\n    queue.setHandler(handler);\n  });\n  return this.run();\n}\n\n//\n// TODO: Remove the polling mechanism using pub/sub.\n//\nPriorityQueue.prototype.run = function() {\n  var _this = this;\n\n  // .reverse() is done in place and therefore mutating the queues array\n  // so a copy is needed to prevent harmful side effects and general voodoo\n  var reversedQueues = _this.queues.slice().reverse();\n\n  var loop = function() {\n    var emptyLoop = true;\n\n    return Promise.each(reversedQueues, function(queue, index) {\n\n      if(_this.closing){\n        return _this.closing;\n      }\n\n      // the index is reversed to the actual priority number (0 is 'critical')\n      // so flip it to get the correct \"priority index\"\n      var nbJobsToProcess = _this.strategy(PriorityQueue.priorities.critical - index);\n      var i = 0;\n\n      var fn = function() {\n        return queue.moveUnlockedJobsToWait().then(queue.getNextJob.bind(queue, {\n            block: false\n          }))\n          .then(function(job) {\n            if (job) {\n              emptyLoop = false;\n              return queue.processJob(job).then(function() {\n                if (++i < nbJobsToProcess && !_this.paused) {\n                  return fn();\n                }\n              })\n            } else {\n              //nothing It will release loop and call next priority queue even if we have no reach nbJobsToProcess\n            }\n          })\n      }\n\n      return fn();\n    }).then(function() {\n      if (!_this.paused) {\n        return Promise.delay((emptyLoop) ? _this.waitAfterEmptyLoop : 0).then(loop);\n      }\n    });\n  }\n\n  return loop();\n}\n\nPriorityQueue.prototype.setLockRenewTime = function(lockRenewTime) {\n  this.queues.forEach(function(queue) {\n    queue.LOCK_RENEW_TIME = lockRenewTime;\n  })\n}\n\nPriorityQueue.prototype.add = function(data, opts) {\n  return this.getQueue(opts && opts.priority).add(data, opts);\n}\n\nPriorityQueue.prototype.empty = function() {\n  return Promise.map(this.queues, function(queue) {\n    return queue.empty();\n  });\n}\n\nPriorityQueue.prototype.pause = function(localOnly) {\n  var _this = this;\n  \n  _this.paused = Promise.map(this.queues, function(queue) {\n    return queue.pause(localOnly || false);\n  }).then(_this.emit.bind(_this, 'paused'));\n\n  return _this.paused;\n}\n\nPriorityQueue.prototype.resume = function(localOnly) {\n  var _this = this;\n  _this.paused = false;\n  return Promise.map(this.queues, function(queue) {\n    return queue.resume(localOnly || false);\n  }).then(_this.emit.bind(_this, 'resumed')).then(function() {\n    if (_this.handler) {\n      _this.run();\n    }\n  });\n}\n\n//See normal queue for options\nPriorityQueue.prototype.clean = function(grace, type) {\n  var _this = this;\n  return Promise.map(this.queues, function(queue) {\n    return queue.clean(grace, type);\n  }).then(function (results) {\n    var jobs = [].concat.apply([], results);\n    var tp = type || 'completed';\n    _this.emit('cleaned', jobs, tp);\n    return Promise.resolve(jobs);\n  });\n}\n\n\nPriorityQueue.prototype.count = function() {\n  return Promise.map(this.queues, function(queue) {\n    return queue.count();\n  }).then(function(results) {\n    var sum = 0;\n    results.forEach(function(val) {\n      sum += val;\n    });\n    return sum;\n  })\n};\n\n/**\n * A generic function to get jobs in all queues\n *\n * @param fnName\n * @returns {Function}\n */\nPriorityQueue.genericGetter = function(fnName) {\n  return function() {\n    var args = arguments;\n    return Promise.map(this.queues, function(queue) {\n      return queue[fnName].apply(queue, args);\n    }).then(function(results) {\n      var jobs = [];\n      results.forEach(function(val) {\n        jobs = jobs.concat(val);\n      });\n      return jobs;\n    })\n  }\n}\n\nPriorityQueue.prototype.getWaiting = PriorityQueue.genericGetter(\"getWaiting\");\nPriorityQueue.prototype.getActive = PriorityQueue.genericGetter(\"getActive\");\nPriorityQueue.prototype.getDelayed = PriorityQueue.genericGetter(\"getDelayed\");\nPriorityQueue.prototype.getCompleted = PriorityQueue.genericGetter(\"getCompleted\");\nPriorityQueue.prototype.getFailed = PriorityQueue.genericGetter(\"getFailed\");\n\n\n// ---------------------------------------------------------------------\n// Private methods\n// ---------------------------------------------------------------------\nPriorityQueue.prototype.getQueue = function(priority) {\n  if (!(priority in PriorityQueue.priorities)) {\n    //in case of unknown priority, we use normal\n    priority = \"normal\";\n  }\n\n  var queue = this.queues[PriorityQueue.priorities[priority]];\n  return queue;\n}\n\nvar Strategy = {};\n\n/**\n * This Strategy ensure that a queue Qn will be processing twice faster as all lower queue.\n * @param n\n * @returns {number}\n */\nStrategy.exponential = function(n) {\n  return Math.pow(n, n) * 2;\n};\n\n/**\n * This strategy is the minimal acceptable to respect the rule Qn will be processing quicker than Qn-1\n *\n * @param n\n * @returns {*}\n */\nStrategy.minimum = function(n) {\n  return n + 1;\n};\n\nStrategy.square = function(n) {\n  return Math.pow(n, 2);\n};\n","/home/travis/build/npmtest/node-npmtest-bull/node_modules/bull/lib/schedule.js":"\n// https://www.npmjs.com/package/cron-parser\n// https://www.npmjs.com/package/human-interval\n\nQueue.prototype.repeat = function(name, period, tz, handler){\n  //\n\n  // var millis = next(period).\n\n  // var customId = queue + name (+ hash(period))\n  // addDelayedJob(name, customId);\n  // \n  // How to avoid missing jobs if time is too tight?\n  // with one worker:\n  //   save the timestamp where the job is supposed to be executed.\n  //   use the saved timestamp to calculate the next scheduled job.\n\n  // with several workers:\n  // same as before. One worker will implicitly become the leader...\n\n}","/home/travis/build/npmtest/node-npmtest-bull/node_modules/bull/lib/state.js":"/**\n\tState machine.\n\n\tDistributed state machine.\n*/\n\nvar machine = Machine('signup', opts); // opts -> redis connection mostly, name of the machine.\n\nmachine.state('send mail', function(data, next){\n\t// In this state we send an email with a confirmation link and exit the state\n\tnext('wait confirmation', data);\n});\n\nmachine.state('wait confirmation'); // // In this state we do nothing we just wait for an external input\n\nmachine.state('confirm user', function(task){\n\treturn data;\n})\n\nmachine.next('wait confirmation', data);\n\n/**\n\tqueue('wait confirmation').add(data);\n*/\nmachine.state('transcode video', function(data){\n\t// transcode...\n\tthis.next('append moov');\n}).catch(function(err){\n\tthis.next('delete tmp');\n});\n\nmachine.state('append moov', input, function(data, next){\n\t// Append MOOV etc.\n\tthis.next('delete tmp');\n});\n\nmachine.next('delete temp', input, function(data, next){\n\t// delete temp file\n\tthis.next('update user account');\n});\n\nmachine.state('update user account', function(data, next){\n\t// update database\n});\n\n\n\n\n"}